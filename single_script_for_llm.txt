======== FILE: .\admin.py ========
import streamlit as st
import pandas as pd
import time
import re
from src import database, utils

# --- AUTH ---
# Password sederhana untuk demo
if 'auth' not in st.session_state: st.session_state.auth = False

def login():
    # Password hardcoded: "veven"
    if st.session_state.pass_input == "veven": 
        st.session_state.auth = True
    else:
        st.error("Password salah")

if not st.session_state.auth:
    st.set_page_config(page_title="Admin Login")
    st.markdown("<h1 style='text-align: center;'>üîí Admin Login</h1>", unsafe_allow_html=True)
    c1, c2, c3 = st.columns([1,1,1])
    with c2:
        st.text_input("Password", type="password", key="pass_input", on_change=login)
    st.stop()

# --- MAIN UI ---
st.set_page_config(page_title="Admin Console", layout="wide")
st.title("üõ†Ô∏è Admin Console (Safe Mode)")
tags_map = utils.load_tags_config()

# State Management
if 'preview_mode' not in st.session_state: st.session_state.preview_mode = False
if 'draft_data' not in st.session_state: st.session_state.draft_data = {}

# Tabs
tab1, tab2, tab3, tab4 = st.tabs(["üìä List Data", "‚ûï Tambah (Preview)", "‚úèÔ∏è Edit/Hapus", "‚öôÔ∏è Config Tags"])

# === TAB 1: LIST DATA ===
with tab1:
    if st.button("üîÑ Refresh Data"):
        st.cache_data.clear() # Clear cache agar data terbaru muncul
        st.rerun()
        
    df = database.get_all_data_as_df()
    st.dataframe(df, use_container_width=True, hide_index=True)

# === TAB 2: TAMBAH DATA (WORKFLOW) ===
with tab2:
    # --- PHASE 1: INPUT FORM ---
    if not st.session_state.preview_mode:
        st.info("üí° Tips: Gunakan [GAMBAR 1] di dalam jawaban untuk menyisipkan gambar.")
        
        col_m, col_j = st.columns([1, 3])
        with col_m: i_tag = st.selectbox("Modul", list(tags_map.keys()), key="in_t")
        with col_j: i_judul = st.text_input("Judul Masalah", key="in_j")
            
        i_jawab = st.text_area("Jawaban / Solusi", height=200, key="in_a", 
                              placeholder="Langkah 1: Klik tombol save.\n[GAMBAR 1]\n\nLangkah 2: Selesai.")
        
        i_key = st.text_input("Keyword Tambahan (Opsional)", key="in_k", placeholder="Contoh: error 505, puyer, resep")
        i_src = st.text_input("URL Sumber (ClickUp/PDF)", key="in_s")
        i_imgs = st.file_uploader("Upload Gambar", accept_multiple_files=True, key="in_i")
        
        if st.button("üîç Lanjut ke Preview", type="primary"):
            if not i_judul or not i_jawab:
                st.error("Judul & Jawaban wajib diisi!")
            else:
                # Simpan draft di memori sementara
                st.session_state.draft_data = {
                    "tag": i_tag, "judul": i_judul, "jawab": i_jawab,
                    "key": i_key, "src": i_src, "imgs": i_imgs
                }
                st.session_state.preview_mode = True
                st.rerun()

    # --- PHASE 2: PREVIEW & SUBMIT ---
    else:
        draft = st.session_state.draft_data
        st.warning("‚ö†Ô∏è Mode Preview: Data belum disimpan ke Database.")
        
        c_back, c_save = st.columns([1, 4])
        with c_back:
            if st.button("‚¨ÖÔ∏è Edit Lagi"):
                st.session_state.preview_mode = False
                st.rerun()
        
        with c_save:
            # INI LOGIC PENTINGNYA
            if st.button("üíæ SIMPAN DATA (PUBLISH)", type="primary"):
                try:
                    with st.spinner("Sedang menyimpan (Menunggu antrian DB)..."):
                        # 1. Simpan Gambar dulu ke Folder Lokal
                        paths = utils.save_uploaded_images(draft['imgs'], draft['judul'], draft['tag'])
                        
                        # 2. Simpan ke DB dengan ID "auto"
                        # Biarkan Backend yang menghitung urutan ID agar tidak bentrok
                        new_id = database.upsert_faq(
                            doc_id="auto", # KUNCINYA DISINI
                            tag=draft['tag'], 
                            judul=draft['judul'], 
                            jawaban=draft['jawab'], 
                            keyword=draft['key'], 
                            img_paths=paths, 
                            src_url=draft['src']
                        )
                        
                        st.success(f"‚úÖ Sukses! Data tersimpan dengan ID: {new_id}")
                        st.session_state.preview_mode = False
                        st.session_state.draft_data = {}
                        database.get_all_data_as_df.clear() # Clear cache tabel
                        time.sleep(2)
                        st.rerun()
                except Exception as e: 
                    st.error(f"Gagal Menyimpan: {e}")

        # --- Tampilan Preview User ---
        st.divider()
        st.subheader("üì± Preview Tampilan User")
        
        hex_color = tags_map.get(draft['tag'], {}).get("color", "#808080")
        st.markdown(f"### <span style='color:{hex_color}'>[{draft['tag']}]</span> {draft['judul']}", unsafe_allow_html=True)
        
        # Render sederhana untuk preview
        parts = re.split(r'(\[GAMBAR\s*\d+\])', draft['jawab'], flags=re.IGNORECASE)
        imgs = draft['imgs'] or []
        
        for part in parts:
            match = re.search(r'\[GAMBAR\s*(\d+)\]', part, re.IGNORECASE)
            if match:
                try:
                    idx = int(match.group(1)) - 1
                    if 0 <= idx < len(imgs):
                        st.image(imgs[idx], width=300, caption=f"Gambar {idx+1}")
                    else:
                        st.caption(f"‚ö†Ô∏è Placeholder [GAMBAR {idx+1}] kosong")
                except: pass
            else:
                if part.strip(): st.markdown(part)

# === TAB 3: EDIT/HAPUS ===
with tab3:
    st.header("‚úèÔ∏è Edit Data Lama")
    df_e = database.get_all_data_as_df()
    
    if not df_e.empty:
        # Dropdown pilih data
        opts = [f"{r['ID']} | {r['Judul']}" for _, r in df_e.iterrows()]
        sel = st.selectbox("Pilih Data untuk Diedit", opts)
        
        if sel:
            sel_id = sel.split(" | ")[0]
            row = df_e[df_e['ID'] == sel_id].iloc[0]
            
            with st.form("edit_form"):
                curr = row['Tag']
                idx = list(tags_map.keys()).index(curr) if curr in tags_map else 0
                
                c_id, c_t = st.columns([1, 4])
                with c_id: st.text_input("ID (Locked)", value=sel_id, disabled=True)
                with c_t: e_tag = st.selectbox("Modul", list(tags_map.keys()), index=idx)
                
                e_jud = st.text_input("Judul", value=row['Judul'])
                e_jaw = st.text_area("Jawaban", value=row['Jawaban'], height=200)
                e_key = st.text_input("Keyword", value=row['Keyword'])
                e_src = st.text_input("Source URL", value=row['Source'])
                
                st.markdown(f"**Path Gambar Saat Ini:** `{row['Gambar']}`")
                st.info("Biarkan kosong jika tidak ingin mengubah gambar.")
                e_new = st.file_uploader("Ganti Gambar (Overwrite)", accept_multiple_files=True)
                
                c_up, c_del = st.columns([1, 1])
                
                # UPDATE BTN
                if c_up.form_submit_button("üíæ UPDATE DATA"):
                    p = row['Gambar']
                    if e_new: 
                        p = utils.save_uploaded_images(e_new, e_jud, e_tag)
                    
                    # Panggil upsert dengan ID LAMA (Update Mode)
                    database.upsert_faq(sel_id, e_tag, e_jud, e_jaw, e_key, p, e_src)
                    
                    st.toast("Update Berhasil!", icon="‚úÖ")
                    database.get_all_data_as_df.clear()
                    time.sleep(1)
                    st.rerun()
                
                # DELETE BTN
                if c_del.form_submit_button("üóëÔ∏è HAPUS PERMANEN", type="primary"):
                    database.delete_faq(sel_id)
                    st.toast("Data Dihapus.", icon="üóëÔ∏è")
                    database.get_all_data_as_df.clear()
                    time.sleep(1)
                    st.rerun()

# === TAB 4: CONFIG ===
with tab4:
    st.header("üé® Pengaturan Tag & Warna")
    flat = [{"Tag":k, "Warna":v.get("color",""), "Desc":v.get("desc","")} 
            for k,v in tags_map.items()]
    st.dataframe(pd.DataFrame(flat), use_container_width=True, hide_index=True)
    
    with st.expander("‚ûï Tambah Tag Baru"):
        with st.form("conf_f", clear_on_submit=True):
            n_name = st.text_input("Nama Tag (ex: Farmasi)")
            n_col = st.selectbox("Warna Badge", list(utils.COLOR_PALETTE.keys()))
            n_desc = st.text_area("Deskripsi AI (Penting untuk search)")
            
            if st.form_submit_button("Simpan Tag"):
                if n_name:
                    hex_c = utils.COLOR_PALETTE[n_col]["hex"]
                    tags_map[n_name] = {"color": hex_c, "desc": n_desc}
                    utils.save_tags_config(tags_map)
                    st.toast("Tag Tersimpan!"); time.sleep(1); st.rerun()

======== FILE: .\app.py ========
import streamlit as st
import os
import math
import re
import warnings
from src import database, utils

# --- 1. CONFIG & SUPPRESS WARNINGS ---
st.set_page_config(page_title="Siloam Knowledge Base", page_icon="üè•", layout="centered")

# Matikan warning deprecation
st.set_option('deprecation.showImageUploaderEncoding', False)
st.set_option('deprecation.showfileUploaderEncoding', False)
warnings.filterwarnings("ignore")

# Load Konfigurasi Tag dari JSON (Single Source of Truth)
# Agar warna sinkron dengan Admin Console
TAGS_MAP = utils.load_tags_config()

# CSS Styling
st.markdown("""
<style>
    div[data-testid="stExpander"] {
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        background-color: white;
        margin-bottom: 10px;
    }
    div[data-testid="stExpander"] p {
        font-size: 15px;
        font-family: sans-serif;
    }
    .stApp {
        background-color: #FAFAFA;
    }
</style>
""", unsafe_allow_html=True)

# --- 2. HELPER FUNGSI ---

def get_badge_color_name(tag):
    """
    Menerjemahkan HEX Code dari tags_config.json menjadi Nama Warna Streamlit.
    Karena syntax :color-background[] tidak support HEX code custom.
    """
    # Ambil Hex dari config JSON berdasarkan Tag
    tag_data = TAGS_MAP.get(tag, {})
    hex_code = tag_data.get("color", "#808080").upper() # Default Gray
    
    # Mapping Hex Config -> Streamlit Color Name
    # Ini sinkron dengan palette di utils.py
    hex_to_name = {
        "#FF4B4B": "red",     # Merah (ED)
        "#2ECC71": "green",   # Hijau (OPD)
        "#3498DB": "blue",    # Biru (IPD/MR/Rehab)
        "#FFA500": "orange",  # Orange (Cashier)
        "#9B59B6": "violet",  # Ungu (Farmasi)
        "#808080": "gray",    # Abu (Umum)
        "#333333": "gray"     # Dark Gray
    }
    
    return hex_to_name.get(hex_code, "gray")

def render_image_safe(image_path):
    if image_path and os.path.exists(image_path):
        st.image(image_path, use_container_width=True)

def render_mixed_content(jawaban_text, images_str):
    if not images_str or str(images_str).lower() == 'none':
        st.markdown(jawaban_text)
        return

    img_list = images_str.split(';')
    img_list = [x for x in img_list if x.strip()]
    parts = re.split(r'(\[GAMBAR\s*\d+\])', jawaban_text, flags=re.IGNORECASE)
    
    # Case 1: Fallback (Gambar di bawah)
    if len(parts) == 1:
        st.markdown(jawaban_text)
        if img_list:
            st.markdown("---")
            cols = st.columns(min(3, len(img_list)))
            for idx, p in enumerate(img_list):
                clean_p = utils.fix_image_path_for_ui(p)
                if clean_p and os.path.exists(clean_p):
                    with cols[idx % 3]:
                        st.image(clean_p, use_container_width=True)
        return

    # Case 2: Inline (Diselipkan)
    for part in parts:
        match = re.search(r'\[GAMBAR\s*(\d+)\]', part, re.IGNORECASE)
        if match:
            try:
                idx = int(match.group(1)) - 1 
                if 0 <= idx < len(img_list):
                    clean_p = utils.fix_image_path_for_ui(img_list[idx])
                    if clean_p and os.path.exists(clean_p):
                        render_image_safe(clean_p)
                    else:
                        st.error(f"üñºÔ∏è File gambar tidak ditemukan: {clean_p}")
                else:
                    st.caption(f"*(Gambar #{idx+1} tidak tersedia)*")
            except ValueError: pass
        else:
            if part.strip(): st.markdown(part)

# --- 3. STATE MANAGEMENT ---
if 'page' not in st.session_state: st.session_state.page = 0
if 'last_query' not in st.session_state: st.session_state.last_query = ""
if 'last_filter' not in st.session_state: st.session_state.last_filter = ""

# --- 4. HEADER UI ---
st.title("üè• EMR FAQ Finder")
st.caption("Knowledge Base Cerdas untuk Staf Medis (Support Semantic Search)")

col_q, col_f = st.columns([3, 1])
with col_q:
    query = st.text_input("Cari Kendala:", placeholder="Ketik masalah (cth: Retur Obat, Error 404)...")
with col_f:
    # Ambil tag unik dari DB agar dropdown dinamis
    try:
        db_tags = database.get_unique_tags_from_db()
    except:
        db_tags = []
    all_tags = ["Semua Modul"] + (db_tags if db_tags else [])
    filter_tag = st.selectbox("Filter:", all_tags)

# --- 5. LOGIC PENCARIAN ---
if query != st.session_state.last_query or filter_tag != st.session_state.last_filter:
    st.session_state.page = 0
    st.session_state.last_query = query
    st.session_state.last_filter = filter_tag

results = []
is_search_mode = False

if query:
    is_search_mode = True
    raw = database.search_faq(query, filter_tag, n_results=50)
    
    if raw['ids'][0]:
        for i in range(len(raw['ids'][0])):
            meta = raw['metadatas'][0][i]
            dist = raw['distances'][0][i]
            score = max(0, (1 - dist) * 100)
            
            # === THRESHOLD 25% ===
            if score > 25:
                meta['score'] = score
                results.append(meta)
else:
    raw_all = database.get_all_faqs_sorted()
    if filter_tag == "Semua Modul":
        results = raw_all
    else:
        results = [x for x in raw_all if x.get('tag') == filter_tag]

# --- 6. PAGINATION & DISPLAY ---
ITEMS_PER_PAGE = 10
total_docs = len(results)
total_pages = math.ceil(total_docs / ITEMS_PER_PAGE)

if st.session_state.page >= total_pages and total_pages > 0:
    st.session_state.page = 0

start_idx = st.session_state.page * ITEMS_PER_PAGE
end_idx = start_idx + ITEMS_PER_PAGE
page_data = results[start_idx:end_idx]

st.divider()

if not page_data:
    if is_search_mode:
        # Catat query gagal ke CSV
        try: utils.log_failed_search(query)
        except: pass
        st.warning(f"‚ùå Tidak ditemukan hasil yang relevan (Relevansi < 25%).")
        st.caption("üîç Query ini telah dicatat sistem untuk perbaikan data.")
    else:
        st.info("üëã Selamat Datang. Database siap digunakan.")
else:
    st.markdown(f"**Menampilkan {start_idx+1}-{min(end_idx, total_docs)} dari {total_docs} data**")
    
    for item in page_data:
        # 1. Badge Warna (DINAMIS DARI CONFIG JSON)
        tag = item.get('tag', 'Umum')
        badge_color = get_badge_color_name(tag)
        
        # 2. Indikator Relevansi
        score_md = ""
        if item.get('score'):
            sc = item['score']
            if sc > 75: sc_color = "green"
            elif sc > 50: sc_color = "orange"
            else: sc_color = "red"
            score_md = f":{sc_color}[({sc:.0f}% Relevansi)]"
            
        label = f":{badge_color}-background[{tag}] **{item.get('judul')}** {score_md}"
        
        with st.expander(label):
            render_mixed_content(item.get('jawaban_tampil', '-'), item.get('path_gambar'))
            if item.get('sumber_url') and len(str(item.get('sumber_url'))) > 3:
                st.markdown(f"üîó [Sumber Referensi]({item.get('sumber_url')})")

    if total_pages > 1:
        st.markdown("---")
        c1, c2, c3 = st.columns([1, 2, 1])
        with c1:
            if st.session_state.page > 0:
                if st.button("‚¨ÖÔ∏è Sebelumnya"):
                    st.session_state.page -= 1; st.rerun()
        with c3:
            if st.session_state.page < total_pages - 1:
                if st.button("Berikutnya ‚û°Ô∏è"):
                    st.session_state.page += 1; st.rerun()

======== FILE: .\docker-compose.yml ========
version: '3'

services:
  # --- SERVICE 1: USER APP (Port 8501) ---
  faq-user:
    build: .
    container_name: faq_user_app
    restart: always
    ports:
      - "8501:8501"
    volumes:
      - ./data:/app/data             # Database Shared (Laptop <-> Docker)
      - ./images:/app/images         # Gambar Shared
      - ./.streamlit:/app/.streamlit # Config Tema
    env_file:
      - .env                         # Baca API Key dari file .env
    # Perintah khusus jalankan User App
    command: streamlit run app.py --server.port=8501 --server.address=0.0.0.0

  # --- SERVICE 2: ADMIN APP (Port 8502) ---
  faq-admin:
    build: .
    container_name: faq_admin_app
    restart: always
    ports:
      - "8502:8502"                  # Buka Pintu Belakang buat Admin
    volumes:
      - ./data:/app/data             # WAJIB SAMA agar Database Sinkron
      - ./images:/app/images         # WAJIB SAMA agar Gambar Sinkron
      - ./.streamlit:/app/.streamlit
    env_file:
      - .env
    # Perintah khusus jalankan Admin Console
    command: streamlit run admin.py --server.port=8502 --server.address=0.0.0.0

======== FILE: .\info_some_syntax.md ========
#Beberapa instruksi tambahan untuk coding assistant AI

======== FILE: .\README.md ========
Fast FAQ system


======== FILE: .\requirements.txt ========
streamlit==1.51.0
chromadb==1.3.4
pandas
google-genai
# pysqlite3-binary PENTING untuk mengatasi limitasi SQLite lama di container Linux
pysqlite3-binary; sys_platform == 'linux'
watchdog

======== FILE: .\single_script_for_llm.txt ========
======== FILE: .\admin.py ========
import streamlit as st
import pandas as pd
import time
import re
from src import database, utils

# --- AUTH ---
# Password sederhana untuk demo
if 'auth' not in st.session_state: st.session_state.auth = False

def login():
    # Password hardcoded: "veven"
    if st.session_state.pass_input == "veven": 
        st.session_state.auth = True
    else:
        st.error("Password salah")

if not st.session_state.auth:
    st.set_page_config(page_title="Admin Login")
    st.markdown("<h1 style='text-align: center;'>üîí Admin Login</h1>", unsafe_allow_html=True)
    c1, c2, c3 = st.columns([1,1,1])
    with c2:
        st.text_input("Password", type="password", key="pass_input", on_change=login)
    st.stop()

# --- MAIN UI ---
st.set_page_config(page_title="Admin Console", layout="wide")
st.title("üõ†Ô∏è Admin Console (Safe Mode)")
tags_map = utils.load_tags_config()

# State Management
if 'preview_mode' not in st.session_state: st.session_state.preview_mode = False
if 'draft_data' not in st.session_state: st.session_state.draft_data = {}

# Tabs
tab1, tab2, tab3, tab4 = st.tabs(["üìä List Data", "‚ûï Tambah (Preview)", "‚úèÔ∏è Edit/Hapus", "‚öôÔ∏è Config Tags"])

# === TAB 1: LIST DATA ===
with tab1:
    if st.button("üîÑ Refresh Data"):
        st.cache_data.clear() # Clear cache agar data terbaru muncul
        st.rerun()
        
    df = database.get_all_data_as_df()
    st.dataframe(df, use_container_width=True, hide_index=True)

# === TAB 2: TAMBAH DATA (WORKFLOW) ===
with tab2:
    # --- PHASE 1: INPUT FORM ---
    if not st.session_state.preview_mode:
        st.info("üí° Tips: Gunakan [GAMBAR 1] di dalam jawaban untuk menyisipkan gambar.")
        
        col_m, col_j = st.columns([1, 3])
        with col_m: i_tag = st.selectbox("Modul", list(tags_map.keys()), key="in_t")
        with col_j: i_judul = st.text_input("Judul Masalah", key="in_j")
            
        i_jawab = st.text_area("Jawaban / Solusi", height=200, key="in_a", 
                              placeholder="Langkah 1: Klik tombol save.\n[GAMBAR 1]\n\nLangkah 2: Selesai.")
        
        i_key = st.text_input("Keyword Tambahan (Opsional)", key="in_k", placeholder="Contoh: error 505, puyer, resep")
        i_src = st.text_input("URL Sumber (ClickUp/PDF)", key="in_s")
        i_imgs = st.file_uploader("Upload Gambar", accept_multiple_files=True, key="in_i")
        
        if st.button("üîç Lanjut ke Preview", type="primary"):
            if not i_judul or not i_jawab:
                st.error("Judul & Jawaban wajib diisi!")
            else:
                # Simpan draft di memori sementara
                st.session_state.draft_data = {
                    "tag": i_tag, "judul": i_judul, "jawab": i_jawab,
                    "key": i_key, "src": i_src, "imgs": i_imgs
                }
                st.session_state.preview_mode = True
                st.rerun()

    # --- PHASE 2: PREVIEW & SUBMIT ---
    else:
        draft = st.session_state.draft_data
        st.warning("‚ö†Ô∏è Mode Preview: Data belum disimpan ke Database.")
        
        c_back, c_save = st.columns([1, 4])
        with c_back:
            if st.button("‚¨ÖÔ∏è Edit Lagi"):
                st.session_state.preview_mode = False
                st.rerun()
        
        with c_save:
            # INI LOGIC PENTINGNYA
            if st.button("üíæ SIMPAN DATA (PUBLISH)", type="primary"):
                try:
                    with st.spinner("Sedang menyimpan (Menunggu antrian DB)..."):
                        # 1. Simpan Gambar dulu ke Folder Lokal
                        paths = utils.save_uploaded_images(draft['imgs'], draft['judul'], draft['tag'])
                        
                        # 2. Simpan ke DB dengan ID "auto"
                        # Biarkan Backend yang menghitung urutan ID agar tidak bentrok
                        new_id = database.upsert_faq(
                            doc_id="auto", # KUNCINYA DISINI
                            tag=draft['tag'], 
                            judul=draft['judul'], 
                            jawaban=draft['jawab'], 
                            keyword=draft['key'], 
                            img_paths=paths, 
                            src_url=draft['src']
                        )
                        
                        st.success(f"‚úÖ Sukses! Data tersimpan dengan ID: {new_id}")
                        st.session_state.preview_mode = False
                        st.session_state.draft_data = {}
                        database.get_all_data_as_df.clear() # Clear cache tabel
                        time.sleep(2)
                        st.rerun()
                except Exception as e: 
                    st.error(f"Gagal Menyimpan: {e}")

        # --- Tampilan Preview User ---
        st.divider()
        st.subheader("üì± Preview Tampilan User")
        
        hex_color = tags_map.get(draft['tag'], {}).get("color", "#808080")
        st.markdown(f"### <span style='color:{hex_color}'>[{draft['tag']}]</span> {draft['judul']}", unsafe_allow_html=True)
        
        # Render sederhana untuk preview
        parts = re.split(r'(\[GAMBAR\s*\d+\])', draft['jawab'], flags=re.IGNORECASE)
        imgs = draft['imgs'] or []
        
        for part in parts:
            match = re.search(r'\[GAMBAR\s*(\d+)\]', part, re.IGNORECASE)
            if match:
                try:
                    idx = int(match.group(1)) - 1
                    if 0 <= idx < len(imgs):
                        st.image(imgs[idx], width=300, caption=f"Gambar {idx+1}")
                    else:
                        st.caption(f"‚ö†Ô∏è Placeholder [GAMBAR {idx+1}] kosong")
                except: pass
            else:
                if part.strip(): st.markdown(part)

# === TAB 3: EDIT/HAPUS ===
with tab3:
    st.header("‚úèÔ∏è Edit Data Lama")
    df_e = database.get_all_data_as_df()
    
    if not df_e.empty:
        # Dropdown pilih data
        opts = [f"{r['ID']} | {r['Judul']}" for _, r in df_e.iterrows()]
        sel = st.selectbox("Pilih Data untuk Diedit", opts)
        
        if sel:
            sel_id = sel.split(" | ")[0]
            row = df_e[df_e['ID'] == sel_id].iloc[0]
            
            with st.form("edit_form"):
                curr = row['Tag']
                idx = list(tags_map.keys()).index(curr) if curr in tags_map else 0
                
                c_id, c_t = st.columns([1, 4])
                with c_id: st.text_input("ID (Locked)", value=sel_id, disabled=True)
                with c_t: e_tag = st.selectbox("Modul", list(tags_map.keys()), index=idx)
                
                e_jud = st.text_input("Judul", value=row['Judul'])
                e_jaw = st.text_area("Jawaban", value=row['Jawaban'], height=200)
                e_key = st.text_input("Keyword", value=row['Keyword'])
                e_src = st.text_input("Source URL", value=row['Source'])
                
                st.markdown(f"**Path Gambar Saat Ini:** `{row['Gambar']}`")
                st.info("Biarkan kosong jika tidak ingin mengubah gambar.")
                e_new = st.file_uploader("Ganti Gambar (Overwrite)", accept_multiple_files=True)
                
                c_up, c_del = st.columns([1, 1])
                
                # UPDATE BTN
                if c_up.form_submit_button("üíæ UPDATE DATA"):
                    p = row['Gambar']
                    if e_new: 
                        p = utils.save_uploaded_images(e_new, e_jud, e_tag)
                    
                    # Panggil upsert dengan ID LAMA (Update Mode)
                    database.upsert_faq(sel_id, e_tag, e_jud, e_jaw, e_key, p, e_src)
                    
                    st.toast("Update Berhasil!", icon="‚úÖ")
                    database.get_all_data_as_df.clear()
                    time.sleep(1)
                    st.rerun()
                
                # DELETE BTN
                if c_del.form_submit_button("üóëÔ∏è HAPUS PERMANEN", type="primary"):
                    database.delete_faq(sel_id)
                    st.toast("Data Dihapus.", icon="üóëÔ∏è")
                    database.get_all_data_as_df.clear()
                    time.sleep(1)
                    st.rerun()

# === TAB 4: CONFIG ===
with tab4:
    st.header("üé® Pengaturan Tag & Warna")
    flat = [{"Tag":k, "Warna":v.get("color",""), "Desc":v.get("desc","")} 
            for k,v in tags_map.items()]
    st.dataframe(pd.DataFrame(flat), use_container_width=True, hide_index=True)
    
    with st.expander("‚ûï Tambah Tag Baru"):
        with st.form("conf_f", clear_on_submit=True):
            n_name = st.text_input("Nama Tag (ex: Farmasi)")
            n_col = st.selectbox("Warna Badge", list(utils.COLOR_PALETTE.keys()))
            n_desc = st.text_area("Deskripsi AI (Penting untuk search)")
            
            if st.form_submit_button("Simpan Tag"):
                if n_name:
                    hex_c = utils.COLOR_PALETTE[n_col]["hex"]
                    tags_map[n_name] = {"color": hex_c, "desc": n_desc}
                    utils.save_tags_config(tags_map)
                    st.toast("Tag Tersimpan!"); time.sleep(1); st.rerun()

======== FILE: .\app.py ========
import streamlit as st
import os
import math
import re
import warnings
from src import database, utils

# --- 1. CONFIG & SUPPRESS WARNINGS ---
st.set_page_config(page_title="Siloam Knowledge Base", page_icon="üè•", layout="centered")

# Matikan warning deprecation
st.set_option('deprecation.showImageUploaderEncoding', False)
st.set_option('deprecation.showfileUploaderEncoding', False)
warnings.filterwarnings("ignore")

# Load Konfigurasi Tag dari JSON (Single Source of Truth)
# Agar warna sinkron dengan Admin Console
TAGS_MAP = utils.load_tags_config()

# CSS Styling
st.markdown("""
<style>
    div[data-testid="stExpander"] {
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        background-color: white;
        margin-bottom: 10px;
    }
    div[data-testid="stExpander"] p {
        font-size: 15px;
        font-family: sans-serif;
    }
    .stApp {
        background-color: #FAFAFA;
    }
</style>
""", unsafe_allow_html=True)

# --- 2. HELPER FUNGSI ---

def get_badge_color_name(tag):
    """
    Menerjemahkan HEX Code dari tags_config.json menjadi Nama Warna Streamlit.
    Karena syntax :color-background[] tidak support HEX code custom.
    """
    # Ambil Hex dari config JSON berdasarkan Tag
    tag_data = TAGS_MAP.get(tag, {})
    hex_code = tag_data.get("color", "#808080").upper() # Default Gray
    
    # Mapping Hex Config -> Streamlit Color Name
    # Ini sinkron dengan palette di utils.py
    hex_to_name = {
        "#FF4B4B": "red",     # Merah (ED)
        "#2ECC71": "green",   # Hijau (OPD)
        "#3498DB": "blue",    # Biru (IPD/MR/Rehab)
        "#FFA500": "orange",  # Orange (Cashier)
        "#9B59B6": "violet",  # Ungu (Farmasi)
        "#808080": "gray",    # Abu (Umum)
        "#333333": "gray"     # Dark Gray
    }
    
    return hex_to_name.get(hex_code, "gray")

def render_image_safe(image_path):
    if image_path and os.path.exists(image_path):
        st.image(image_path, use_container_width=True)

def render_mixed_content(jawaban_text, images_str):
    if not images_str or str(images_str).lower() == 'none':
        st.markdown(jawaban_text)
        return

    img_list = images_str.split(';')
    img_list = [x for x in img_list if x.strip()]
    parts = re.split(r'(\[GAMBAR\s*\d+\])', jawaban_text, flags=re.IGNORECASE)
    
    # Case 1: Fallback (Gambar di bawah)
    if len(parts) == 1:
        st.markdown(jawaban_text)
        if img_list:
            st.markdown("---")
            cols = st.columns(min(3, len(img_list)))
            for idx, p in enumerate(img_list):
                clean_p = utils.fix_image_path_for_ui(p)
                if clean_p and os.path.exists(clean_p):
                    with cols[idx % 3]:
                        st.image(clean_p, use_container_width=True)
        return

    # Case 2: Inline (Diselipkan)
    for part in parts:
        match = re.search(r'\[GAMBAR\s*(\d+)\]', part, re.IGNORECASE)
        if match:
            try:
                idx = int(match.group(1)) - 1 
                if 0 <= idx < len(img_list):
                    clean_p = utils.fix_image_path_for_ui(img_list[idx])
                    if clean_p and os.path.exists(clean_p):
                        render_image_safe(clean_p)
                    else:
                        st.error(f"üñºÔ∏è File gambar tidak ditemukan: {clean_p}")
                else:
                    st.caption(f"*(Gambar #{idx+1} tidak tersedia)*")
            except ValueError: pass
        else:
            if part.strip(): st.markdown(part)

# --- 3. STATE MANAGEMENT ---
if 'page' not in st.session_state: st.session_state.page = 0
if 'last_query' not in st.session_state: st.session_state.last_query = ""
if 'last_filter' not in st.session_state: st.session_state.last_filter = ""

# --- 4. HEADER UI ---
st.title("üè• EMR FAQ Finder")
st.caption("Knowledge Base Cerdas untuk Staf Medis (Support Semantic Search)")

col_q, col_f = st.columns([3, 1])
with col_q:
    query = st.text_input("Cari Kendala:", placeholder="Ketik masalah (cth: Retur Obat, Error 404)...")
with col_f:
    # Ambil tag unik dari DB agar dropdown dinamis
    try:
        db_tags = database.get_unique_tags_from_db()
    except:
        db_tags = []
    all_tags = ["Semua Modul"] + (db_tags if db_tags else [])
    filter_tag = st.selectbox("Filter:", all_tags)

# --- 5. LOGIC PENCARIAN ---
if query != st.session_state.last_query or filter_tag != st.session_state.last_filter:
    st.session_state.page = 0
    st.session_state.last_query = query
    st.session_state.last_filter = filter_tag

results = []
is_search_mode = False

if query:
    is_search_mode = True
    raw = database.search_faq(query, filter_tag, n_results=50)
    
    if raw['ids'][0]:
        for i in range(len(raw['ids'][0])):
            meta = raw['metadatas'][0][i]
            dist = raw['distances'][0][i]
            score = max(0, (1 - dist) * 100)
            
            # === THRESHOLD 25% ===
            if score > 25:
                meta['score'] = score
                results.append(meta)
else:
    raw_all = database.get_all_faqs_sorted()
    if filter_tag == "Semua Modul":
        results = raw_all
    else:
        results = [x for x in raw_all if x.get('tag') == filter_tag]

# --- 6. PAGINATION & DISPLAY ---
ITEMS_PER_PAGE = 10
total_docs = len(results)
total_pages = math.ceil(total_docs / ITEMS_PER_PAGE)

if st.session_state.page >= total_pages and total_pages > 0:
    st.session_state.page = 0

start_idx = st.session_state.page * ITEMS_PER_PAGE
end_idx = start_idx + ITEMS_PER_PAGE
page_data = results[start_idx:end_idx]

st.divider()

if not page_data:
    if is_search_mode:
        # Catat query gagal ke CSV
        try: utils.log_failed_search(query)
        except: pass
        st.warning(f"‚ùå Tidak ditemukan hasil yang relevan (Relevansi < 25%).")
        st.caption("üîç Query ini telah dicatat sistem untuk perbaikan data.")
    else:
        st.info("üëã Selamat Datang. Database siap digunakan.")
else:
    st.markdown(f"**Menampilkan {start_idx+1}-{min(end_idx, total_docs)} dari {total_docs} data**")
    
    for item in page_data:
        # 1. Badge Warna (DINAMIS DARI CONFIG JSON)
        tag = item.get('tag', 'Umum')
        badge_color = get_badge_color_name(tag)
        
        # 2. Indikator Relevansi
        score_md = ""
        if item.get('score'):
            sc = item['score']
            if sc > 75: sc_color = "green"
            elif sc > 50: sc_color = "orange"
            else: sc_color = "red"
            score_md = f":{sc_color}[({sc:.0f}% Relevansi)]"
            
        label = f":{badge_color}-background[{tag}] **{item.get('judul')}** {score_md}"
        
        with st.expander(label):
            render_mixed_content(item.get('jawaban_tampil', '-'), item.get('path_gambar'))
            if item.get('sumber_url') and len(str(item.get('sumber_url'))) > 3:
                st.markdown(f"üîó [Sumber Referensi]({item.get('sumber_url')})")

    if total_pages > 1:
        st.markdown("---")
        c1, c2, c3 = st.columns([1, 2, 1])
        with c1:
            if st.session_state.page > 0:
                if st.button("‚¨ÖÔ∏è Sebelumnya"):
                    st.session_state.page -= 1; st.rerun()
        with c3:
            if st.session_state.page < total_pages - 1:
                if st.button("Berikutnya ‚û°Ô∏è"):
                    st.session_state.page += 1; st.rerun()

======== FILE: .\docker-compose.yml ========
version: '3'

services:
  # --- SERVICE 1: USER APP (Port 8501) ---
  faq-user:
    build: .
    container_name: faq_user_app
    restart: always
    ports:
      - "8501:8501"
    volumes:
      - ./data:/app/data             # Database Shared (Laptop <-> Docker)
      - ./images:/app/images         # Gambar Shared
      - ./.streamlit:/app/.streamlit # Config Tema
    env_file:
      - .env                         # Baca API Key dari file .env
    # Perintah khusus jalankan User App
    command: streamlit run app.py --server.port=8501 --server.address=0.0.0.0

  # --- SERVICE 2: ADMIN APP (Port 8502) ---
  faq-admin:
    build: .
    container_name: faq_admin_app
    restart: always
    ports:
      - "8502:8502"                  # Buka Pintu Belakang buat Admin
    volumes:
      - ./data:/app/data             # WAJIB SAMA agar Database Sinkron
      - ./images:/app/images         # WAJIB SAMA agar Gambar Sinkron
      - ./.streamlit:/app/.streamlit
    env_file:
      - .env
    # Perintah khusus jalankan Admin Console
    command: streamlit run admin.py --server.port=8502 --server.address=0.0.0.0

======== FILE: .\.streamlit\config.toml ========

[theme]
base="light"
primaryColor="#FF4B4B"
backgroundColor="#FFFFFF"
secondaryBackgroundColor="#F0F2F6"
textColor="#31333F"
font="sans serif"


======== FILE: .\src\config.py ========
import os

# --- API KEYS ---
# Pastikan file .env sudah ada dan berisi GOOGLE_API_KEY
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY") 

if not GOOGLE_API_KEY:
    # Warning log di console server
    raise ValueError("‚ùå GOOGLE_API_KEY belum diset! Cek file .env atau environment server.")

# --- PATHS CONFIGURATION ---
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

# Folder Database ChromaDB
DB_PATH = os.path.join(BASE_DIR, "data", "faq_db")

# File Konfigurasi Tag (JSON)
TAGS_FILE = os.path.join(BASE_DIR, "data", "tags_config.json")

# Folder Gambar
IMAGES_DIR = os.path.join(BASE_DIR, "images")

# Nama Collection di ChromaDB
COLLECTION_NAME = "faq_universal_v1"

# Setup Folder jika belum ada
os.makedirs(os.path.join(BASE_DIR, "data"), exist_ok=True)
os.makedirs(IMAGES_DIR, exist_ok=True)

======== FILE: .\src\database.py ========
# --- 1. FORCE USE NEW SQLITE (Wajib Paling Atas untuk Docker/Linux) ---
try:
    __import__('pysqlite3')
    import sys
    sys.modules['sqlite3'] = sys.modules.pop('pysqlite3')
except ImportError:
    pass

# --- 2. IMPORTS ---
import chromadb
import pandas as pd
import streamlit as st
import time
import functools
import random  # Penting untuk jitter (jeda acak)
from google import genai
from google.genai import types
from .config import GOOGLE_API_KEY, DB_PATH, COLLECTION_NAME
from .utils import load_tags_config, clean_text_for_embedding

# --- 3. RETRY DECORATOR (SAFE CONCURRENCY) ---
def retry_on_lock(max_retries=10, base_delay=0.1):
    """
    Decorator untuk menangani Database Locked (SQLite).
    Menggunakan 'Random Jitter' agar jika 5 user akses bareng,
    mereka tidak mencoba ulang di detik yang sama persis.
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    # Cek error spesifik SQLite Locked/Busy
                    err_msg = str(e).lower()
                    if "locked" in err_msg or "busy" in err_msg:
                        retries += 1
                        # Sleep acak antara 0.1s s/d 0.2s (Jitter)
                        sleep_time = base_delay * (1 + random.random())
                        time.sleep(sleep_time)
                        # print(f"‚ö†Ô∏è DB Locked, retrying {retries}/{max_retries}...")
                    else:
                        raise e  # Error lain (coding error) tetap dilempar
            raise Exception("Database sedang sibuk (High Traffic), silakan coba lagi sesaat.")
        return wrapper
    return decorator

# --- 4. CLIENT INITIALIZATION (CACHED) ---
@st.cache_resource(show_spinner=False)
def get_db_client():
    return chromadb.PersistentClient(path=DB_PATH)

@st.cache_resource(show_spinner=False)
def get_ai_client():
    return genai.Client(api_key=GOOGLE_API_KEY)

def get_collection():
    client = get_db_client()
    return client.get_or_create_collection(name=COLLECTION_NAME)

# --- 5. EMBEDDING (CACHED) ---
@st.cache_data(show_spinner=False)
def generate_embedding_cached(text):
    client = get_ai_client()
    try:
        response = client.models.embed_content(
            model="models/gemini-embedding-001",
            contents=text,
            config=types.EmbedContentConfig(task_type="RETRIEVAL_DOCUMENT")
        )
        return response.embeddings[0].values
    except Exception as e:
        print(f"‚ö†Ô∏è Error Embedding AI: {e}")
        return []

# --- 6. INTERNAL HELPER (ID GENERATOR) ---
def _get_next_id_internal(collection):
    """
    Hitung ID max + 1. 
    Fungsi ini dipanggil DALAM lock upsert agar thread-safe.
    """
    data = collection.get(include=[])
    existing_ids = data['ids']
    
    if not existing_ids: 
        return "1"
    
    numeric_ids = []
    for x in existing_ids:
        # Filter hanya ID angka agar sorting benar (1, 2, 10, bukan 1, 10, 2)
        if x.isdigit(): 
            numeric_ids.append(int(x))
    
    if not numeric_ids: 
        return "1"
        
    return str(max(numeric_ids) + 1)

# --- 7. CORE LOGIC (READ - USER) ---

@retry_on_lock()
def search_faq(query_text, filter_tag=None, n_results=50):
    col = get_collection()
    vec = generate_embedding_cached(query_text)
    
    if not vec: 
        return {"ids": [[]], "metadatas": [[]], "distances": [[]]}

    # Pre-Filtering logic
    where_clause = {"tag": filter_tag} if (filter_tag and filter_tag != "Semua Modul") else None
    
    return col.query(
        query_embeddings=[vec],
        n_results=n_results,
        where=where_clause
    )

@retry_on_lock()
def get_all_faqs_sorted():
    col = get_collection()
    data = col.get(include=['metadatas'])
    
    results = []
    if data['ids']:
        for i, doc_id in enumerate(data['ids']):
            meta = data['metadatas'][i]
            
            # Defense: Handle jika ID bukan angka
            try: id_num = int(doc_id)
            except: id_num = 0
            
            meta['id'] = doc_id
            meta['id_num'] = id_num
            results.append(meta)
            
    # Sort descending (Terbaru diatas)
    results.sort(key=lambda x: x.get('id_num', 0), reverse=True)
    return results

def get_unique_tags_from_db():
    col = get_collection()
    data = col.get(include=['metadatas'])
    unique_tags = set()
    if data['metadatas']:
        for meta in data['metadatas']:
            if meta and meta.get('tag'):
                unique_tags.add(meta['tag'])
    return sorted(list(unique_tags))

# --- 8. CORE LOGIC (WRITE - ADMIN) ---

def get_all_data_as_df():
    """Mengambil data lengkap untuk Tabel Admin"""
    col = get_collection()
    data = col.get(include=['metadatas', 'documents', 'embeddings'])
    
    if not data['ids']: return pd.DataFrame()
    
    rows = []
    for i, doc_id in enumerate(data['ids']):
        meta = data['metadatas'][i]
        rows.append({
            "ID": doc_id,
            "Tag": meta.get('tag'),
            "Judul": meta.get('judul'),
            "Jawaban": meta.get('jawaban_tampil'),
            "Keyword": meta.get('keywords_raw'),
            "Gambar": meta.get('path_gambar'),
            "Source": meta.get('sumber_url'),
            "AI Context": data['documents'][i] if data['documents'] else ""
        })
    
    df = pd.DataFrame(rows)
    # Sorting numeric untuk tabel
    df['ID_Num'] = pd.to_numeric(df['ID'], errors='coerce').fillna(0)
    return df.sort_values('ID_Num', ascending=False).drop(columns=['ID_Num'])

@retry_on_lock()
def upsert_faq(doc_id, tag, judul, jawaban, keyword, img_paths, src_url):
    col = get_collection()
    
    # KUNCI LOGIKA: 
    # Jika doc_id diisi (saat Edit), gunakan itu.
    # Jika doc_id="auto" (saat New), generate baru.
    final_id = str(doc_id)
    if doc_id == "auto" or doc_id is None:
        final_id = _get_next_id_internal(col)
    
    # 1. Text Cleaning (Hapus [GAMBAR X] agar AI tidak bingung)
    clean_jawaban = clean_text_for_embedding(jawaban)
    
    # 2. Build Context Prompt
    text_embed = f"""MODUL: {tag}
PERTANYAAN: {judul}
SOLUSI TEKNIS: {clean_jawaban}
KEYWORD: {keyword}"""
    
    # 3. Generate Vector
    vector = generate_embedding_cached(text_embed)
    
    # 4. Upsert ke ChromaDB
    col.upsert(
        ids=[final_id],
        embeddings=[vector],
        documents=[text_embed],
        metadatas=[{
            "tag": tag, 
            "judul": judul, 
            "jawaban_tampil": jawaban, # Simpan yg asli (ada marker [GAMBAR]) untuk user UI
            "keywords_raw": keyword,
            "path_gambar": img_paths,
            "sumber_url": src_url
        }]
    )
    return final_id  # Return ID agar Admin Console bisa menampilkan pesan sukses

@retry_on_lock()
def delete_faq(doc_id):
    col = get_collection()
    col.delete(ids=[str(doc_id)])

======== FILE: .\src\utils.py ========
import os
import json
import re
import random
import string
import time
import csv
from datetime import datetime
from .config import TAGS_FILE, IMAGES_DIR, BASE_DIR 

# --- DAFTAR WARNA RESMI STREAMLIT (Restricted Palette) ---
# Admin hanya boleh memilih warna ini agar badge di UI User valid
COLOR_PALETTE = {
    "Merah":            {"hex": "#FF4B4B", "name": "red"},
    "Hijau":            {"hex": "#2ECC71", "name": "green"},
    "Biru":             {"hex": "#3498DB", "name": "blue"},
    "Orange":           {"hex": "#FFA500", "name": "orange"},
    "Ungu":             {"hex": "#9B59B6", "name": "violet"},
    "Abu-abu":          {"hex": "#808080", "name": "gray"},
    "Pelangi (Special)":{"hex": "#333333", "name": "rainbow"}
}

# --- 1. JSON TAG CONFIG ---
def load_tags_config():
    if not os.path.exists(TAGS_FILE):
        # Default struktur (Nested Dict)
        default_tags = {
            "ED": {"color": "#FF4B4B", "desc": "IGD, Emergency, Triage, Ambulans"},
            "OPD": {"color": "#2ECC71", "desc": "Rawat Jalan, Poli, Dokter Spesialis"},
            "IPD": {"color": "#3498DB", "desc": "Rawat Inap, Bangsal, Bed, Visite"},
            "Umum": {"color": "#808080", "desc": "General Info, IT Support"}
        }
        save_tags_config(default_tags)
        return default_tags
    with open(TAGS_FILE, "r") as f:
        return json.load(f)

def save_tags_config(tags_dict):
    with open(TAGS_FILE, "w") as f:
        json.dump(tags_dict, f, indent=4)

# --- 2. SAFE ID GENERATOR ---
def get_next_id_safe(collection):
    try:
        data = collection.get(include=[])
        existing_ids = data['ids']
        if not existing_ids: return "1"
        
        # Filter hanya ID angka agar sorting benar
        numeric_ids = []
        for x in existing_ids:
            if x.isdigit():
                numeric_ids.append(int(x))
        
        if not numeric_ids: return "1"
        return str(max(numeric_ids) + 1)
    except Exception:
        return str(int(time.time()))

# --- 3. IMAGE HANDLING ---
def sanitize_filename(text):
    # Membersihkan nama file dari karakter aneh
    return re.sub(r'[^\w\-_]', '', text.replace(" ", "_"))[:30]

def save_uploaded_images(uploaded_files, judul, tag):
    if not uploaded_files: return "none"
    
    saved_paths = []
    clean_judul = sanitize_filename(judul)
    target_dir = os.path.join(IMAGES_DIR, tag)
    os.makedirs(target_dir, exist_ok=True)
    
    for i, file in enumerate(uploaded_files):
        ext = file.name.split('.')[-1]
        # Tambah random suffix biar gak bentrok
        suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
        
        filename = f"{clean_judul}_{tag}_{i+1}_{suffix}.{ext}"
        full_path = os.path.join(target_dir, filename)
        
        with open(full_path, "wb") as f:
            f.write(file.getbuffer())
            
        # Simpan relative path agar portable (Docker/Local)
        rel_path = f"./images/{tag}/{filename}"
        saved_paths.append(rel_path)
        
    return ";".join(saved_paths)

def fix_image_path_for_ui(db_path):
    clean = str(db_path).strip('"').strip("'")
    if clean.lower() == "none": return None
    clean = clean.replace("\\", "/")
    if clean.startswith("./"):
        return clean 
    return clean

# --- 4. TEXT CLEANING FOR AI ---
def clean_text_for_embedding(text):
    """
    Menghapus tag [GAMBAR X] agar tidak menjadi noise bagi AI.
    Tapi MEMPERTAHANKAN markdown seperti **bold** atau list.
    Contoh: "Klik [GAMBAR 1] tombol save" -> "Klik tombol save"
    """
    if not text: return ""
    # Hapus pattern [GAMBAR angka] case insensitive
    clean = re.sub(r'\[GAMBAR\s*\d+\]', '', text, flags=re.IGNORECASE)
    # Hapus whitespace berlebih akibat penghapusan tadi
    return " ".join(clean.split())

def log_failed_search(query):
    """Mencatat pencarian yang hasilnya 0 ke file CSV"""
    filename = os.path.join(BASE_DIR, "data", "failed_searches.csv")
    
    # Cek header kalau file baru
    file_exists = os.path.exists(filename)
    
    try:
        with open(filename, mode='a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            if not file_exists:
                writer.writerow(["Timestamp", "Query User"]) # Header
            
            writer.writerow([datetime.now().strftime("%Y-%m-%d %H:%M:%S"), query])
    except Exception as e:
        print(f"Gagal mencatat log: {e}")

======== FILE: .\src\__init__.py ========


