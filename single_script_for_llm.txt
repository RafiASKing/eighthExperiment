======== FILE: .\admin.py ========
import streamlit as st
import pandas as pd
import time
import re
from src import database, utils
from src.config import ADMIN_PASSWORD, FAILED_SEARCH_LOG

# --- AUTH SYSTEM ---
if 'auth' not in st.session_state: st.session_state.auth = False

def login():
    if st.session_state.pass_input == ADMIN_PASSWORD: 
        st.session_state.auth = True
    else:
        st.error("Password salah")

if not st.session_state.auth:
    st.set_page_config(page_title="Admin Login")
    st.markdown("<h1 style='text-align: center;'>üîí Admin Login</h1>", unsafe_allow_html=True)
    c1, c2, c3 = st.columns([1,1,1])
    with c2:
        st.text_input("Password", type="password", key="pass_input", on_change=login)
    st.stop()

# --- MAIN UI SETUP ---
st.set_page_config(page_title="Admin Console", layout="wide")
st.title("üõ†Ô∏è Admin Console (Safe Mode)")
tags_map = utils.load_tags_config()

# State Management
if 'preview_mode' not in st.session_state: st.session_state.preview_mode = False
if 'draft_data' not in st.session_state: st.session_state.draft_data = {}

# Tabs
tab1, tab2, tab3, tab4, tab5 = st.tabs([
    "üìä Database", "‚ûï New FaQ", "‚úèÔ∏è Edit/Delete FaQ", "‚öôÔ∏è Config Tags", "üìà Analytics"
])

# === TAB 1: LIST DATA ===
with tab1:
    if st.button("üîÑ Refresh Data"):
        # CLEAR CACHE DISINI (MANUAL REFRESH)
        database.get_all_data_as_df.clear()
        st.rerun()
        
    df = database.get_all_data_as_df()
    st.dataframe(df, use_container_width=True, hide_index=True)

# === TAB 2: TAMBAH DATA (SMART EDITOR) ===
with tab2:
    # --- SMART CALLBACKS ---
    def add_text(text):
        """Menambahkan teks (Bold/List) ke akhir editor"""
        if 'in_a' in st.session_state:
            st.session_state.in_a += text

    def add_next_image_tag():
        """
        FITUR PINTAR (AUTO COUNTER):
        Otomatis scan teks, hitung jumlah tag [GAMBAR X], 
        lalu tambahkan [GAMBAR X+1].
        """
        current_text = st.session_state.get('in_a', "")
        matches = re.findall(r'\[GAMBAR\s*\d+\]', current_text, flags=re.IGNORECASE)
        next_num = len(matches) + 1
        
        tag_to_insert = f"\n[GAMBAR {next_num}]\n"
        st.session_state.in_a += tag_to_insert

    # --- PHASE 1: INPUT FORM ---
    if not st.session_state.preview_mode:
        # Load Draft (Anti-Amnesia Logic)
        default_tag = st.session_state.draft_data.get('tag', list(tags_map.keys())[0])
        default_judul = st.session_state.draft_data.get('judul', '')
        default_jawab = st.session_state.draft_data.get('jawab', '')
        default_key = st.session_state.draft_data.get('key', '')
        default_src = st.session_state.draft_data.get('src', '')
        
        try: idx_tag = list(tags_map.keys()).index(default_tag)
        except: idx_tag = 0

        st.subheader("üìù FaQ/SOP Baru")
        
        # Row 1: Module & Judul
        col_m, col_j = st.columns([1, 3])
        with col_m: i_tag = st.selectbox("Modul", list(tags_map.keys()), index=idx_tag, key="in_t")
        with col_j: i_judul = st.text_input("Judul Masalah (Pertanyaan/SOP)", value=default_judul, key="in_j")
            
        # Row 2: Smart Toolbar & Editor
        st.markdown("**Jawaban / Solusi:**")
        
        # Toolbar Layout
        tb1, tb2, tb3, tb_spacer = st.columns([1, 1, 2, 4])
        
        tb1.button("ùóï Bold", on_click=add_text, args=(" **teks tebal** ",), 
                   help="Tebalkan teks", use_container_width=True)
        
        tb2.button("Bars", on_click=add_text, args=("\n- Langkah 1\n- Langkah 2",), 
                   help="Buat List", use_container_width=True)
        
        # Tombol Ajaib
        tb3.button("+ Klik ini untuk add penanda gambar", on_click=add_next_image_tag, 
                   type="primary", icon="üñºÔ∏è", use_container_width=True,
                   help="Otomatis memasukkan tag [GAMBAR 1], [GAMBAR 2], dst.")

        # Text Area Utama
        i_jawab = st.text_area("Editor", value=default_jawab, height=300, key="in_a", label_visibility="collapsed")
        st.caption("üí° *Tips: Klik tombol 'üì∏' untuk memasukkan placeholder gambar secara urut.*")
        
        # Row 3: Meta Info & Upload
        c_k, c_s = st.columns(2)
        with c_k: 
            st.markdown("Term terkait / Bahasa User (HyDE) üëá")
            i_key = st.text_input("Hidden Label", value=default_key, key="in_k", 
                                  placeholder="Contoh: Gabisa login, User not found, Kok gagal discharge?...",
                                  label_visibility="collapsed",
                                  help="Masukkan kata-kata yang mungkin diketik user saat panik.")
            
        with c_s: 
            st.markdown("Sumber Info/Source URL")
            i_src = st.text_input("Hidden Label 2", value=default_src, key="in_s", label_visibility="collapsed")
        
        i_imgs = st.file_uploader("Upload Gambar", accept_multiple_files=True, key="in_i")
        
        st.divider()
        if st.button("üîç Lanjut ke Preview", type="primary", use_container_width=True):
            if not i_judul or not i_jawab:
                st.error("Judul & Jawaban wajib diisi!")
            else:
                # Simpan Draft ke Session State
                st.session_state.draft_data = {
                    "tag": i_tag, "judul": i_judul, "jawab": i_jawab,
                    "key": i_key, "src": i_src, "imgs": i_imgs
                }
                st.session_state.preview_mode = True
                st.rerun()

    # --- PHASE 2: PREVIEW & SUBMIT ---
    else:
        draft = st.session_state.draft_data
        
        st.info("üì± **Mode Preview:** Periksa tampilan sebelum Publish.")
        
        # Simulasi Tampilan User (Card)
        with st.container(border=True):
            hex_color = tags_map.get(draft['tag'], {}).get("color", "#808080")
            st.markdown(f"### <span style='color:{hex_color}'>[{draft['tag']}]</span> {draft['judul']}", unsafe_allow_html=True)
            st.caption(f"üîë Keywords/HyDE: {draft['key']}")
            st.divider()
            
            # Logic Render Gambar Sederhana untuk Preview
            parts = re.split(r'(\[GAMBAR\s*\d+\])', draft['jawab'], flags=re.IGNORECASE)
            imgs = draft['imgs'] or []
            
            for part in parts:
                match = re.search(r'\[GAMBAR\s*(\d+)\]', part, re.IGNORECASE)
                if match:
                    try:
                        idx = int(match.group(1)) - 1
                        if 0 <= idx < len(imgs):
                            st.image(imgs[idx], width=400, caption=f"Gambar {idx+1}")
                        else:
                            st.warning(f"‚ö†Ô∏è [GAMBAR {idx+1}] ditulis tapi file belum diupload.")
                    except: pass
                else:
                    if part.strip(): st.markdown(part)
        
        st.divider()
        c_back, c_save = st.columns([1, 3])
        
        with c_back:
            if st.button("‚¨ÖÔ∏è Edit Lagi", use_container_width=True):
                st.session_state.preview_mode = False
                st.rerun()
        
        with c_save:
            if st.button("üíæ PUBLISH KE DATABASE", type="primary", use_container_width=True):
                try:
                    with st.spinner("Menyimpan ke ChromaDB..."):
                        # 1. Simpan Gambar ke Disk
                        paths = utils.save_uploaded_images(draft['imgs'], draft['judul'], draft['tag'])
                        
                        # 2. Upsert ke DB
                        new_id = database.upsert_faq(
                            doc_id="auto",
                            tag=draft['tag'], 
                            judul=draft['judul'], 
                            jawaban=draft['jawab'], 
                            keyword=draft['key'], 
                            img_paths=paths, 
                            src_url=draft['src']
                        )
                        
                        st.balloons()
                        st.success(f"‚úÖ Data Tersimpan! ID Dokumen: {new_id}")
                        
                        # === [1] CLEAR CACHE (WAJIB) ===
                        database.get_all_data_as_df.clear()
                        
                        # Reset
                        st.session_state.preview_mode = False
                        st.session_state.draft_data = {}
                        time.sleep(2)
                        st.rerun()
                except Exception as e: 
                    st.error(f"Error Save: {e}")

# === TAB 3: EDIT/HAPUS ===
with tab3:
    st.header("‚úèÔ∏è Edit Data Lama")
    df_e = database.get_all_data_as_df()
    
    if not df_e.empty:
        opts = [f"{r['ID']} | {r['Judul']}" for _, r in df_e.iterrows()]
        sel = st.selectbox("Pilih Data", opts)
        
        if sel:
            sel_id = sel.split(" | ")[0]
            row = df_e[df_e['ID'] == sel_id].iloc[0]
            
            with st.form("edit_form"):
                curr = row['Tag']
                idx = list(tags_map.keys()).index(curr) if curr in tags_map else 0
                
                c_id, c_t = st.columns([1, 4])
                with c_id: st.text_input("ID", value=sel_id, disabled=True)
                with c_t: e_tag = st.selectbox("Modul", list(tags_map.keys()), index=idx)
                
                e_jud = st.text_input("Judul SOP", value=row['Judul'])
                e_jaw = st.text_area("Jawaban (Gunakan [GAMBAR X])", value=row['Jawaban'], height=200)
                e_key = st.text_input("Keyword / Bahasa User (HyDE)", value=row['Keyword'], help="Isi dengan variasi pertanyaan user.")
                e_src = st.text_input("Source URL", value=row['Source'])
                
                st.markdown(f"**Path Gambar Saat Ini:** `{row['Gambar']}`")
                e_new = st.file_uploader("Timpa Gambar Baru (Opsional)", accept_multiple_files=True)
                
                st.divider() # Garis pemisah biar rapi
                
                # --- PERUBAHAN DI SINI ---
                # Kita buat layout 3 kolom: 
                # Kolom 1 (Besar): Tombol Update
                # Kolom 2 (Kecil): Spacer (kosong)
                # Kolom 3 (Sedang): Tombol Hapus
                c_up, c_space, c_del = st.columns([4, 0.5, 2])
                
                with c_up:
                    # UPDATE jadi PRIMARY (Warna #FF4B4B/Orange sesuai config)
                    # Biar user "terpancing" klik yang ini
                    is_update = st.form_submit_button("üíæ UPDATE DATA", type="primary", use_container_width=True)
                
                with c_del:
                    # HAPUS jadi SECONDARY (Abu-abu/Putih)
                    # Biar gak mencolok & mengurangi resiko salah klik
                    is_delete = st.form_submit_button("üóëÔ∏è Hapus Permanen", type="secondary", use_container_width=True)
                
                # --- LOGIC TOMBOL ---
                
                if is_update:
                    p = row['Gambar']
                    if e_new: 
                        p = utils.save_uploaded_images(e_new, e_jud, e_tag)
                    
                    database.upsert_faq(sel_id, e_tag, e_jud, e_jaw, e_key, p, e_src)
                    st.toast("Data Berhasil Diupdate!", icon="‚úÖ")
                    
                    # Clear Cache & Rerun
                    database.get_all_data_as_df.clear()
                    time.sleep(1)
                    st.rerun()
                
                if is_delete:
                    database.delete_faq(sel_id)
                    st.toast("Data & Gambar Telah Dihapus.", icon="üóëÔ∏è")
                    
                    # Clear Cache & Rerun
                    database.get_all_data_as_df.clear()
                    time.sleep(1)
                    st.rerun()

# === TAB 4: CONFIG ===
with tab4:
    st.subheader("‚öôÔ∏è Konfigurasi Tag")
    
    # Tampilkan Tabel Config Saat Ini
    flat = [{"Tag":k, "Warna":v.get("color",""), "Sinonim":v.get("desc","")} for k,v in tags_map.items()]
    st.dataframe(pd.DataFrame(flat), use_container_width=True, hide_index=True)
    
    st.divider()

    # --- BAGIAN 1: TAMBAH / EDIT ---
    with st.expander("‚ûï Tambah / Update Tag", expanded=True):
        with st.form("conf_f", clear_on_submit=True):
            c1, c2 = st.columns(2)
            with c1: n_name = st.text_input("Nama Tag (ex: ED)", help="Jika nama sama dengan yg ada, akan mengupdate data.")
            with c2: n_col = st.selectbox("Warna Badge", list(utils.COLOR_PALETTE.keys()))
            n_desc = st.text_input("Sinonim / Kepanjangan", placeholder="ex: Emergency, Poli, Medical Record")
            
            if st.form_submit_button("Simpan Konfigurasi"):
                if n_name:
                    # Validasi sederhana biar gak kosong
                    hex_c = utils.COLOR_PALETTE[n_col]["hex"]
                    tags_map[n_name] = {"color": hex_c, "desc": n_desc}
                    utils.save_tags_config(tags_map)
                    st.toast(f"Tag '{n_name}' berhasil disimpan!", icon="‚úÖ")
                    time.sleep(1)
                    st.rerun()
                else:
                    st.warning("Nama Tag wajib diisi.")

    # --- BAGIAN 2: HAPUS TAG (REQUEST KAMU) ---
    with st.expander("üóëÔ∏è Hapus Tag ", expanded=False):
        st.markdown("### Hapus Tag dari Sistem")
        
        # Dropdown pilih tag yg mau dihapus
        del_tag = st.selectbox("Pilih Tag untuk dihapus", list(tags_map.keys()), key="del_tag_sel")
        
        # --- SAFETY CHECK: Cek apakah tag ini masih dipakai di DB? ---
        # Kita ambil data DF yg sudah dicache di Tab 1/3
        df_check = database.get_all_data_as_df()
        if not df_check.empty:
            count_usage = len(df_check[df_check['Tag'] == del_tag])
        else:
            count_usage = 0
            
        # Tampilkan Warning sesuai kondisi
        if count_usage > 0:
            st.error(f"‚ö†Ô∏è **PERINGATAN KERAS:** Tag `{del_tag}` saat ini masih digunakan oleh **{count_usage} Dokumen** FaQ!")
            st.markdown("""
            **Saran:** Sebaiknya edit dulu dokumen tersebut di Tab 'Edit/Delete FaQ' dan ganti tag-nya sebelum menghapus tag ini.
            Jika tetap dihapus, dokumen lama akan kehilangan warna badge (menjadi abu-abu/default).
            """)
        else:
            st.success(f"‚úÖ Aman: Tidak ada dokumen aktif yang menggunakan tag `{del_tag}`.")

        # Tombol Hapus dengan konfirmasi visual
        c_del_warn, c_del_btn = st.columns([3, 1])
        with c_del_btn:
            if st.button("üî• Hapus Tag Ini", type="primary", use_container_width=True):
                if del_tag in tags_map:
                    del tags_map[del_tag]
                    utils.save_tags_config(tags_map)
                    st.toast(f"Tag '{del_tag}' telah dihapus permanen.", icon="üóëÔ∏è")
                    time.sleep(1)
                    st.rerun()

# === TAB 5: ANALYTICS (FEEDBACK LOOP) ===
with tab5:
    st.subheader("üìà Pencarian Gagal (User Feedback)")
    st.caption("Daftar kata kunci yang dicari User tapi hasilnya < 32% (Tidak Relevan).")
    
    if utils.os.path.exists(FAILED_SEARCH_LOG):
        df_log = pd.read_csv(FAILED_SEARCH_LOG)
        
        col1, col2 = st.columns([4, 1])
        with col1:
            st.metric("Total Miss", len(df_log))
        with col2:
            if st.button("üóëÔ∏è Clear Log"):
                utils.os.remove(FAILED_SEARCH_LOG)
                st.rerun()
                
        if not df_log.empty:
            df_log = df_log.sort_values(by="Timestamp", ascending=False)
            st.dataframe(df_log, use_container_width=True)
    else:
        st.info("Belum ada data pencarian gagal. Sistem bekerja dengan baik!")

======== FILE: .\app.py ========
import streamlit as st
import os
import math
import re
import warnings
from src import database, utils

# --- 1. CONFIG & SUPPRESS WARNINGS ---
st.set_page_config(page_title="Siloam Knowledge Base", page_icon="üè•", layout="centered")

# Matikan warning deprecation
# (Kode lama dihapus karena sudah tidak supported di Streamlit baru)
warnings.filterwarnings("ignore")

# Load Konfigurasi Tag dari JSON (Single Source of Truth)
TAGS_MAP = utils.load_tags_config()

# CSS Styling
st.markdown("""
<style>
    div[data-testid="stExpander"] {
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        background-color: white;
        margin-bottom: 10px;
    }
    div[data-testid="stExpander"] p {
        font-size: 15px;
        font-family: sans-serif;
    }
    .stApp {
        background-color: #FAFAFA;
    }
</style>
""", unsafe_allow_html=True)

# --- 2. HELPER FUNGSI ---

def get_badge_color_name(tag):
    """
    Menerjemahkan HEX Code dari tags_config.json menjadi Nama Warna Streamlit.
    """
    tag_data = TAGS_MAP.get(tag, {})
    hex_code = tag_data.get("color", "#808080").upper() 
    
    hex_to_name = {
        "#FF4B4B": "red",     # Merah (ED)
        "#2ECC71": "green",   # Hijau (OPD)
        "#3498DB": "blue",    # Biru (IPD/MR/Rehab)
        "#FFA500": "orange",  # Orange (Cashier)
        "#9B59B6": "violet",  # Ungu (Farmasi)
        "#808080": "gray",    # Abu (Umum)
        "#333333": "gray"     # Dark Gray
    }
    
    return hex_to_name.get(hex_code, "gray")

def render_image_safe(image_path):
    if image_path and os.path.exists(image_path):
        st.image(image_path, use_container_width=True)

def render_mixed_content(jawaban_text, images_str):
    if not images_str or str(images_str).lower() == 'none':
        st.markdown(jawaban_text)
        return

    img_list = images_str.split(';')
    img_list = [x for x in img_list if x.strip()]
    parts = re.split(r'(\[GAMBAR\s*\d+\])', jawaban_text, flags=re.IGNORECASE)
    
    # Case 1: Fallback (Gambar di bawah)
    if len(parts) == 1:
        st.markdown(jawaban_text)
        if img_list:
            st.markdown("---")
            cols = st.columns(min(3, len(img_list)))
            for idx, p in enumerate(img_list):
                clean_p = utils.fix_image_path_for_ui(p)
                if clean_p and os.path.exists(clean_p):
                    with cols[idx % 3]:
                        st.image(clean_p, use_container_width=True)
        return

    # Case 2: Inline (Diselipkan)
    for part in parts:
        match = re.search(r'\[GAMBAR\s*(\d+)\]', part, re.IGNORECASE)
        if match:
            try:
                idx = int(match.group(1)) - 1 
                if 0 <= idx < len(img_list):
                    clean_p = utils.fix_image_path_for_ui(img_list[idx])
                    if clean_p and os.path.exists(clean_p):
                        render_image_safe(clean_p)
                    else:
                        st.error(f"üñºÔ∏è File gambar tidak ditemukan: {clean_p}")
                else:
                    st.caption(f"*(Gambar #{idx+1} tidak tersedia)*")
            except ValueError: pass
        else:
            if part.strip(): st.markdown(part)

# --- 3. STATE MANAGEMENT ---
if 'page' not in st.session_state: st.session_state.page = 0
if 'last_query' not in st.session_state: st.session_state.last_query = ""
if 'last_filter' not in st.session_state: st.session_state.last_filter = ""

# --- 4. HEADER UI ---
st.title("‚ö°Fast Cognitive Search System")
st.caption("Smart Knowledge Base Retrieval")

col_q, col_f = st.columns([3, 1])
with col_q:
    query = st.text_input("Cari isu/kendala:", placeholder="Ketik masalah (cth: Kenapa Gagal Retur Obat, gagal discharge)...")
with col_f:
    # Ambil tag unik dari DB agar dropdown dinamis
    try:
        db_tags = database.get_unique_tags_from_db()
    except:
        db_tags = []
    all_tags = ["Semua Modul"] + (db_tags if db_tags else [])
    filter_tag = st.selectbox("Filter:", all_tags)

# --- 5. LOGIC PENCARIAN ---
if query != st.session_state.last_query or filter_tag != st.session_state.last_filter:
    st.session_state.page = 0
    st.session_state.last_query = query
    st.session_state.last_filter = filter_tag

results = []
is_search_mode = False

if query:
    is_search_mode = True
    # Tetap ambil agak banyak dari DB (misal 10 atau 20) buat kandidat
    raw = database.search_faq(query, filter_tag, n_results=50) 
    
    if raw['ids'][0]:
        for i in range(len(raw['ids'][0])):
            meta = raw['metadatas'][0][i]
            dist = raw['distances'][0][i]
            score = max(0, (1 - dist) * 100)
            
            # 1. TETAPKAN SYARAT MINIMUM 32%
            if score > 32:
                meta['score'] = score
                results.append(meta)
        
        # 2. üëá TAMBAHKAN BARIS INI (PEMOTONG) üëá
        # Ini artinya: "Ambil list results dari urutan ke-0 sampai ke-3 aja"
        results = results[:3]
else:
    raw_all = database.get_all_faqs_sorted()
    if filter_tag == "Semua Modul":
        results = raw_all
    else:
        results = [x for x in raw_all if x.get('tag') == filter_tag]

# --- 6. PAGINATION & DISPLAY ---
ITEMS_PER_PAGE = 10
total_docs = len(results)
total_pages = math.ceil(total_docs / ITEMS_PER_PAGE)

if st.session_state.page >= total_pages and total_pages > 0:
    st.session_state.page = 0

start_idx = st.session_state.page * ITEMS_PER_PAGE
end_idx = start_idx + ITEMS_PER_PAGE
page_data = results[start_idx:end_idx]

st.divider()

if not page_data:
    if is_search_mode:
        # Catat query gagal ke CSV
        try: utils.log_failed_search(query)
        except: pass
        
        # === CALL TO ACTION (WA BOT) ===
        st.warning(f"‚ùå Tidak ditemukan hasil yang relevan (Relevansi < 32%).")
        
        st.markdown("""
        ### üßê Belum ada solusinya?
        Sistem telah mencatat pencarianmu untuk perbaikan. Sementara itu, kamu bisa:
        
        1. Coba gunakan kata kunci yang lebih umum.
        2. Atau langsung request bantuan ke Tim IT Support:
        """)
        
        # GANTI NOMOR WA DI SINI (Format: 628xxx)
        wa_number = "6289635225253" 
        wa_text = f"Halo Admin, saya cari solusi tentang '{query}' tapi tidak ketemu di aplikasi FAQ."
        wa_link = f"https://wa.me/{wa_number}?text={wa_text.replace(' ', '%20')}"
        
        st.markdown(f'''
        <a href="{wa_link}" target="_blank" style="text-decoration: none;">
            <button style="
                background-color: #25D366; 
                color: white; 
                padding: 10px 20px; 
                border: none; 
                border-radius: 5px; 
                cursor: pointer;
                font-weight: bold;
                font-size: 16px;
                display: flex;
                align_items: center;
                gap: 8px;">
                üì± Chat WhatsApp Support
            </button>
        </a>
        ''', unsafe_allow_html=True)
        # ===============================
        
    else:
        st.info("üëã Selamat Datang. Database siap digunakan.")
else:
    st.markdown(f"**Menampilkan {start_idx+1}-{min(end_idx, total_docs)} dari {total_docs} data**")
    
    for item in page_data:
        # 1. Badge Warna Modul
        tag = item.get('tag', 'Umum')
        badge_color = get_badge_color_name(tag)
        
        # 2. Indikator Relevansi (CUSTOM COLOR LOGIC) üé®
        score_md = ""
        if item.get('score'):
            sc = item['score']
            
            # --- ATURAN WARNA BARU ---
            if sc > 80:
                # > 80%: "Ijo Tua" (Kita pake Green + BOLD + Bintang biar beda)
                # Streamlit cuma punya 1 green, jadi kita tebalkan biar tegas.
                score_md = f":green[**({sc:.0f}% Relevansi) üåü**]"
            
            elif sc > 50:
                # 50% - 80%: "Ijo Muda" (Green biasa/tipis)
                score_md = f":green[({sc:.0f}% Relevansi)]"
            
            elif sc > 36:
                # 37% - 50%: Orange
                score_md = f":orange[({sc:.0f}% Relevansi)]"
            
            else:
                # 32% - 36%: Merah
                score_md = f":red[({sc:.0f}% Relevansi)]"
            
        label = f":{badge_color}-background[{tag}] **{item.get('judul')}** {score_md}"
        
        with st.expander(label):
            render_mixed_content(item.get('jawaban_tampil', '-'), item.get('path_gambar'))
            if item.get('sumber_url') and len(str(item.get('sumber_url'))) > 3:
                st.markdown(f"üîó [Sumber Referensi]({item.get('sumber_url')})")

    if total_pages > 1:
        st.markdown("---")
        c1, c2, c3 = st.columns([1, 2, 1])
        with c1:
            if st.session_state.page > 0:
                if st.button("‚¨ÖÔ∏è Sebelumnya"):
                    st.session_state.page -= 1
                    st.rerun()
        with c3:
            if st.session_state.page < total_pages - 1:
                if st.button("Berikutnya ‚û°Ô∏è"):
                    st.session_state.page += 1
                    st.rerun()

======== FILE: .\bot_wa.py ========
import os
import requests
import uvicorn
import re
import base64
from fastapi import FastAPI, Request, BackgroundTasks
from dotenv import load_dotenv
from src import database

# Load Environment Variables
load_dotenv()

app = FastAPI()

# Konfigurasi Evolution API
# Default URL container internal. Ganti instance jika perlu.
EVO_BASE_URL = os.getenv("EVO_BASE_URL", "http://evolution-api:8081")
EVO_API_KEY = os.getenv("EVO_API_KEY", "admin123")
INSTANCE_NAME = "faq_bot" 

def get_base64_image(file_path):
    """
    Encode gambar lokal ke Base64 Murni.
    Evolution API lebih simpel, tidak butuh header 'data:image...'
    """
    try:
        clean_path = file_path.replace("\\", "/")
        if not os.path.exists(clean_path): return None, None
        
        with open(clean_path, "rb") as image_file:
            encoded_string = base64.b64encode(image_file.read()).decode('utf-8')
            
        # Evolution butuh filename dan base64 string saja
        return encoded_string, os.path.basename(clean_path)
    except Exception as e:
        print(f"‚ùå Gagal encode gambar: {e}")
        return None, None

def send_evo_text(remote_jid, text):
    """Kirim Teks via Evolution API"""
    url = f"{EVO_BASE_URL}/message/sendText/{INSTANCE_NAME}"
    headers = {"apikey": EVO_API_KEY, "Content-Type": "application/json"}
    
    # Pastikan nomor formatnya benar (hapus @s.whatsapp.net jika ada, tapi Evolution biasanya pintar)
    if "@" in remote_jid: remote_jid = remote_jid.split("@")[0]

    payload = {
        "number": remote_jid, 
        "text": text
    }
    try:
        r = requests.post(url, json=payload, headers=headers)
        # print(f"üì§ Sent Text: {r.status_code}")
    except Exception as e:
        print(f"‚ùå Error Send Text: {e}")

def send_evo_image(remote_jid, file_path, caption=""):
    """Kirim Gambar via Evolution API"""
    url = f"{EVO_BASE_URL}/message/sendMedia/{INSTANCE_NAME}"
    headers = {"apikey": EVO_API_KEY, "Content-Type": "application/json"}
    
    if "@" in remote_jid: remote_jid = remote_jid.split("@")[0]

    base64_str, filename = get_base64_image(file_path)
    if not base64_str: return

    payload = {
        "number": remote_jid,
        "medias": [{
            "type": "image",
            "caption": caption,
            "data": base64_str,
            "fileName": filename
        }]
    }
    try:
        r = requests.post(url, json=payload, headers=headers)
        print(f"üñºÔ∏è Sent Image: {r.status_code}")
    except Exception as e:
        print(f"‚ùå Error Send Image: {e}")

def process_logic(remote_jid, sender_name, message_body, is_group, has_mention):
    """
    Otak Bot:
    - Balas jika Chat Pribadi (PC)
    - Balas jika Grup DAN (Dimention ATAU ada keyword @faq)
    """
    
    # 1. LOGIKA TRIGGER
    should_reply = False
    
    if not is_group:
        # PC: Selalu balas
        should_reply = True
    else:
        # Group: Cek trigger
        if has_mention:
            should_reply = True
        elif "@faq" in message_body.lower():
            should_reply = True
            
    if not should_reply: return

    # 2. CLEANING QUERY
    # Hapus @faq dan mention format WA (@628123...) agar search bersih
    clean_query = message_body.replace("@faq", "").strip()
    clean_query = re.sub(r'@\d+', '', clean_query).strip()

    if not clean_query:
        send_evo_text(remote_jid, f"Halo {sender_name}, silakan ketik pertanyaanmu.")
        return

    print(f"üîç Searching: '{clean_query}' (From: {sender_name})")

    # 3. SEARCH DATABASE
    results = database.search_faq_for_bot(clean_query, filter_tag="Semua Modul")
    
    reply_text = ""
    list_gambar_to_send = []

    if not results or not results['ids'][0]:
        reply_text = f"üôè Maaf {sender_name}, tidak ditemukan jawaban untuk: *'{clean_query}'*."
        send_evo_text(remote_jid, reply_text)
        return
    else:
        # Ambil Top 1
        meta = results['metadatas'][0][0]
        dist = results['distances'][0][0]
        score = max(0, (1 - dist) * 100)

        # Ambang batas kepercayaan (bisa diatur)
        if score < 60:
             reply_text = f"ü§î Kurang yakin ({score:.0f}%):\n\n"
        else:
             reply_text = f"ü§ñ *FAQ Assistant* ({score:.0f}%)\n\n"

        judul = meta['judul']
        jawaban_raw = meta['jawaban_tampil']
        
        # 4. PARSING GAMBAR (Fitur Request Kamu)
        # Ambil path gambar dari database
        raw_paths = meta.get('path_gambar', 'none')
        img_db_list = []
        if raw_paths and str(raw_paths).lower() != 'none':
             paths = raw_paths.split(';')
             for p in paths:
                 # Normalisasi path windows/linux
                 img_db_list.append(p.strip().replace("\\", "/"))

        # Fungsi ganti teks [GAMBAR 1] -> (Lihat Gambar)
        def replace_tag(match):
            try:
                # match.group(1) itu angkanya (1, 2, dst)
                idx = int(match.group(1)) - 1
                if 0 <= idx < len(img_db_list):
                    list_gambar_to_send.append(img_db_list[idx])
                    return f"*( üëá Lihat Gambar {idx+1} )*"
                return ""
            except: return ""

        # Lakukan penggantian teks
        jawaban_processed = re.sub(r'\[GAMBAR\s*(\d+)\]', replace_tag, jawaban_raw, flags=re.IGNORECASE)
        
        # Fallback: Jika ada gambar tapi tidak ditulis [GAMBAR X] di teks, kirim semua
        if not list_gambar_to_send and img_db_list:
            list_gambar_to_send = img_db_list

        # Susun Pesan
        reply_text += f"‚ùì *{judul}*\n‚úÖ {jawaban_processed}\n"
        if meta.get('sumber_url'): reply_text += f"\nüîó {meta.get('sumber_url')}"

        # 5. KIRIM HASIL
        send_evo_text(remote_jid, reply_text)
        
        # Kirim Gambar Asli
        for i, img_path in enumerate(list_gambar_to_send):
            send_evo_image(remote_jid, img_path, caption=f"Gambar #{i+1} untuk {judul}")

@app.post("/webhook")
async def evolution_webhook(request: Request, background_tasks: BackgroundTasks):
    """
    Webhook Handler - Menerima data dari Evolution API
    """
    try:
        body = await request.json()
        
        # Struktur Evolution: { "event": "...", "data": { ... } }
        event_type = body.get("event")
        data = body.get("data", {})
        
        # Kita hanya peduli kalau ada pesan masuk (messages.upsert)
        if event_type == "messages.upsert":
            msg = data
            
            # 1. Cek Pesan Diri Sendiri (Abaikan)
            if msg.get("key", {}).get("fromMe"): return {"status": "ignored_self"}
            
            # 2. Ambil Nomor Pengirim (Remote JID)
            remote_jid = msg.get("key", {}).get("remoteJid")
            
            # Abaikan status broadcast WhatsApp
            if "status@broadcast" in remote_jid: return {"status": "ignored_status"}

            # 3. Ambil Isi Pesan
            message_body = ""
            # Pesan Text Biasa
            if "conversation" in msg.get("message", {}):
                message_body = msg["message"]["conversation"]
            # Pesan Text dengan Format (Bold/Reply/Mention)
            elif "extendedTextMessage" in msg.get("message", {}):
                message_body = msg["message"]["extendedTextMessage"].get("text", "")
            # Kalau gambar caption
            elif "imageMessage" in msg.get("message", {}):
                message_body = msg["message"]["imageMessage"].get("caption", "")

            sender_name = msg.get("pushName", "User")
            
            # 4. Cek Tipe Chat (Grup atau Pribadi)
            is_group = "@g.us" in remote_jid
            
            # 5. Cek Mention (LOGIKA YANG SAYA KEMBALIKAN)
            has_mention = False
            if is_group:
                # Di Evolution, mention ada di dalam extendedTextMessage > contextInfo > mentionedJid
                context_info = msg.get("message", {}).get("extendedTextMessage", {}).get("contextInfo", {})
                mentioned_jids = context_info.get("mentionedJid", [])
                
                # Jika list mentionedJid TIDAK kosong, berarti ada yang ditag.
                # Asumsi: Kalau bot ada di grup dan ada tag, kemungkinan besar bot yang ditag
                # (Karena kita gak bisa cek nomor sendiri secara dinamis tanpa API call tambahan)
                if mentioned_jids:
                    has_mention = True

            # Jalankan logika utama di background
            background_tasks.add_task(
                process_logic, 
                remote_jid, 
                sender_name, 
                message_body, 
                is_group, 
                has_mention
            )
            
        return {"status": "ok"}
    except Exception as e:
        print(f"Webhook Error: {e}")
        return {"status": "error"}

@app.get("/")
def home():
    return {"status": "Evolution Bot Running", "engine": "Evolution API v2"}

if __name__ == "__main__":
    # Port 8000 sesuai docker-compose
    uvicorn.run("bot_wa:app", host="0.0.0.0", port=8000)

======== FILE: .\docker-compose.yml ========
version: '3'

services:
  # --- 1. CHROMA DB ---
  chroma-server:
    image: chromadb/chroma:latest
    container_name: faq_chroma_server
    restart: always
    ports:
      - "8000:8000"
    volumes:
      - ./data/chroma_data:/data
    environment:
      - IS_PERSISTENT=TRUE
      - ANONYMIZED_TELEMETRY=False

  # --- 2. POSTGRES DATABASE ---
  postgres:
    image: postgres:15-alpine
    container_name: faq_postgres
    restart: always
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: adminpassword
      POSTGRES_DB: evolution
    volumes:
      # GANTI KE V5 (Clean Start Otomatis)
      - ./postgres_data_v5:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 10

  # --- 3. EVOLUTION API ---
# --- 3. EVOLUTION API ---
  evolution-api:
    image: evoapicloud/evolution-api:latest
    container_name: faq_evolution
    restart: always
    ports:
      - "8081:8081"
    depends_on:
      postgres:
        condition: service_healthy
    volumes:
      - ./evolution.env:/evolution/.env
      - ./evolution_instances_v5:/evolution/instances
      - ./evolution_store_v5:/evolution/store
    environment:
      - SERVER_TYPE=http    # <--- ADD THIS HERE TOO
      - DATABASE_URL=postgresql://postgres:adminpassword@faq_postgres:5432/evolution?schema=public
      - DATABASE_PROVIDER=postgresql
      - SERVER_PORT=8081
      - SERVER_URL=http://localhost:8081
      - AUTHENTICATION_API_KEY=admin123
      - AUTHENTICATION_EXPOSE_IN_URL=true
      - LOG_LEVEL=DEBUG
    env_file:
      - evolution.env

  # --- 4. BOT WA ---
  faq-bot:
    build: .
    container_name: faq_bot_wa
    restart: always
    ports:
      - "8005:8000"
    depends_on:
      - chroma-server
      - evolution-api
    env_file: .env
    environment:
      - CHROMA_HOST=chroma-server
      - CHROMA_PORT=8000
      - EVO_BASE_URL=http://evolution-api:8081
      - EVO_API_KEY=admin123
    command: uvicorn bot_wa:app --host 0.0.0.0 --port 8000

  # --- 5. USER APP ---
  faq-user:
    build: .
    container_name: faq_user_app
    restart: always
    ports:
      - "8501:8501"
    depends_on:
      - chroma-server
    volumes:
      - ./data:/app/data
      - ./images:/app/images
      - ./.streamlit:/app/.streamlit
    env_file: .env
    environment:
      - CHROMA_HOST=chroma-server
      - CHROMA_PORT=8000
    command: streamlit run app.py --server.port=8501 --server.address=0.0.0.0

  # --- 6. ADMIN APP ---
  faq-admin:
    build: .
    container_name: faq_admin_app
    restart: always
    ports:
      - "8502:8502"
    depends_on:
      - chroma-server
    volumes:
      - ./data:/app/data
      - ./images:/app/images
      - ./.streamlit:/app/.streamlit
    env_file: .env
    environment:
      - CHROMA_HOST=chroma-server
      - CHROMA_PORT=8000
    command: streamlit run admin.py --server.port=8502 --server.address=0.0.0.0

  # --- 7. FRONTEND V2 ---
  faq-web-v2:
    build: .
    container_name: faq_web_v2
    restart: always
    ports:
      - "8080:8080"
    depends_on:
      - chroma-server
    volumes:
      - ./data:/app/data
      - ./web_v2:/app/web_v2
    env_file: .env
    environment:
      - CHROMA_HOST=chroma-server
      - CHROMA_PORT=8000
    command: uvicorn web_v2.main:app --host 0.0.0.0 --port 8080

======== FILE: .\requirements.txt ========
streamlit==1.51.0
chromadb==1.3.4
pandas
google-genai
python-dotenv
fastapi
uvicorn
requests
# pysqlite3-binary PENTING untuk mengatasi limitasi SQLite lama di container Linux
pysqlite3-binary; sys_platform == 'linux'
watchdog
jinja2
python-multipart
markdown

======== FILE: .\test_bot.py ========
import os
import sys

# Setup path agar bisa import dari folder src
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from src import database
# IMPORT CONFIG DARI SINI
from src.config import BOT_MIN_SCORE, BOT_MIN_GAP

def simulasi_otak_bot(raw_text, filter_tag="Semua Modul"):
    # 1. BERSIHKAN INPUT
    clean_query = raw_text.replace("@botFaQ", "").replace("@botfaq", "").strip()
    
    if not clean_query:
        return "‚ö†Ô∏è Masukkan pertanyaan setelah @botFaQ."

    print(f"\nüß† Sedang memproses: '{clean_query}' [Tag: {filter_tag}]...")

    # 2. PANGGIL DATABASE
    results = database.search_faq_for_bot(clean_query, filter_tag)

    if not results or not results['ids'][0]:
        return "‚ùå Maaf, tidak ditemukan data yang relevan di database."

    # 3. EXTRACTION & SCORING
    candidates = []
    for i in range(len(results['ids'][0])):
        meta = results['metadatas'][0][i]
        dist = results['distances'][0][i]
        score = max(0, (1 - dist) * 100)
        
        # Cek apakah ada gambar
        has_image = False
        img_path = meta.get('path_gambar', 'none')
        if img_path and str(img_path).lower() != 'none':
            has_image = True

        candidates.append({
            "score": score,
            "judul": meta.get('judul'),
            "tag": meta.get('tag'),
            "jawaban": meta.get('jawaban_tampil'),
            "url": meta.get('sumber_url', '-'),
            "has_image": has_image
        })

    top1 = candidates[0]
    top2 = candidates[1] if len(candidates) > 1 else None

    # ==========================================
    # üöÄ LOGIKA CERDAS (PAKE CONFIG ENV)
    # ==========================================
    
    is_winner_absolute = False
    
    # Gunakan Variabel dari Config
    if top1['score'] >= BOT_MIN_SCORE:
        if top2:
            gap = top1['score'] - top2['score']
            if gap >= BOT_MIN_GAP: # Cek Gap dari Config
                is_winner_absolute = True
                print(f"DEBUG: Winner Mutlak! Score: {top1['score']:.1f}, Gap: {gap:.1f}")
            else:
                print(f"DEBUG: Score tinggi tapi saingan ketat. Gap cuma {gap:.1f}")
        else:
            is_winner_absolute = True

    # ==========================================
    # üì§ OUTPUT GENERATION
    # ==========================================

    response_text = ""

    if is_winner_absolute:
        response_text += f"üéØ *SOLUSI DITEMUKAN* (Akurasi: {top1['score']:.0f}%)\n"
        response_text += f"üìÇ Modul: {top1['tag']}\n\n"
        response_text += f"*{top1['judul']}*\n"
        response_text += f"{top1['jawaban']}\n\n"
        
        # Tambahan Indikator Gambar
        if top1['has_image']:
            response_text += "üñºÔ∏è *[Gambar Terlampir]*\n\n"
            
        if top1['url'] and len(top1['url']) > 3:
             response_text += f"üîó Sumber: {top1['url']}"

    else:
        response_text += "üîç *MUNGKIN INI YANG KAMU CARI:*\n"
        if top1['score'] < 25:
             response_text += "(Relevansi rendah, coba kata kunci lain)\n"
        
        limit = min(3, len(candidates))
        for i in range(limit):
            c = candidates[i]
            icon = "1Ô∏è‚É£" if i == 0 else ("2Ô∏è‚É£" if i == 1 else "3Ô∏è‚É£")
            link_txt = f" (üîó {c['url']})" if (c['url'] and len(c['url'])>3) else ""
            img_icon = " üñºÔ∏è" if c['has_image'] else ""
            
            response_text += f"\n{icon} *[{c['tag']}] {c['judul']}*{img_icon} {link_txt}"
            response_text += f"\n   ‚îî‚îÄ Relevansi: {c['score']:.1f}%"
    
    return response_text

if __name__ == "__main__":
    print("="*50)
    print("ü§ñ TEST BOT SIMULATOR (LOCAL)")
    print(f"‚öôÔ∏è Config Loaded: Min Score={BOT_MIN_SCORE}, Min Gap={BOT_MIN_GAP}")
    print("="*50)
    
    CURRENT_TAG_CONTEXT = "Semua Modul" 

    while True:
        try:
            user_input = input("\nüí¨ User: ")
            if user_input.lower() in ['exit', 'quit']:
                break
            balasan = simulasi_otak_bot(user_input, filter_tag=CURRENT_TAG_CONTEXT)
            print("-" * 20)
            print("ü§ñ Bot:\n" + balasan)
            print("-" * 20) 
        except KeyboardInterrupt:
            break

======== FILE: .\.streamlit\config.toml ========

[theme]
base="light"
primaryColor="#FF4B4B"
backgroundColor="#FFFFFF"
secondaryBackgroundColor="#F0F2F6"
textColor="#31333F"
font="sans serif"


======== FILE: .\src\config.py ========
import os
from dotenv import load_dotenv

# Load environment variables dari file .env
load_dotenv()

# --- API KEYS & AUTH ---
GOOGLE_API_KEY = os.getenv("GOOGLE_API_KEY")
ADMIN_PASSWORD = os.getenv("ADMIN_PASSWORD", "veven")

if not GOOGLE_API_KEY:
    raise ValueError("‚ùå GOOGLE_API_KEY belum diset! Cek file .env.")

# --- PATHS CONFIGURATION ---
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DB_PATH = os.path.join(BASE_DIR, "data", "faq_db")
TAGS_FILE = os.path.join(BASE_DIR, "data", "tags_config.json")
IMAGES_DIR = os.path.join(BASE_DIR, "images")
FAILED_SEARCH_LOG = os.path.join(BASE_DIR, "data", "failed_searches.csv")
COLLECTION_NAME = "faq_universal_v1"

# Setup Folder
os.makedirs(os.path.join(BASE_DIR, "data"), exist_ok=True)
os.makedirs(IMAGES_DIR, exist_ok=True)

# --- BOT LOGIC CONFIGURATION (NEW) ---
# Mengambil nilai dari .env, default ke 80.0 dan 10.0 jika tidak ada
try:
    BOT_MIN_SCORE = float(os.getenv("BOT_MIN_SCORE", "80.0"))
    BOT_MIN_GAP = float(os.getenv("BOT_MIN_GAP", "10.0"))
except ValueError:
    print("‚ö†Ô∏è Format angka di .env salah, menggunakan default (80.0 & 10.0)")
    BOT_MIN_SCORE = 80.0
    BOT_MIN_GAP = 10.0

======== FILE: .\src\database.py ========
# --- 1. FORCE USE NEW SQLITE (Wajib Paling Atas untuk Docker/Linux) ---
try:
    __import__('pysqlite3')
    import sys
    sys.modules['sqlite3'] = sys.modules.pop('pysqlite3')
except ImportError:
    pass

# --- 2. IMPORTS LENGKAP ---
import chromadb
import pandas as pd
import streamlit as st
import time
import functools
import random
import os
from google import genai
from google.genai import types
from .config import GOOGLE_API_KEY, DB_PATH, COLLECTION_NAME
from .utils import clean_text_for_embedding, load_tags_config

# --- 3. RETRY DECORATOR (SAFE CONCURRENCY) ---
def retry_on_lock(max_retries=10, base_delay=0.1):
    """
    Menangani error 'Database Locked' pada SQLite dengan Jitter Backoff.
    Aman digunakan oleh Streamlit maupun Bot eksternal.
    """
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            retries = 0
            while retries < max_retries:
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    err_msg = str(e).lower()
                    if "locked" in err_msg or "busy" in err_msg:
                        retries += 1
                        sleep_time = base_delay * (1 + random.random())
                        time.sleep(sleep_time)
                    else:
                        raise e
            raise Exception("Database sedang sibuk (High Traffic), silakan coba lagi sesaat.")
        return wrapper
    return decorator

# --- 4. RAW FUNCTIONS (UNTUK BOT WA / API) ---
# Fungsi-fungsi ini TIDAK menggunakan @st.cache, jadi aman dipanggil script luar.

def _get_ai_client_raw():
    """Membuat koneksi ke Google Gemini (Tanpa Cache Streamlit)"""
    return genai.Client(api_key=GOOGLE_API_KEY)

def _get_db_client_raw():
    """
    Logika Cerdas:
    Cek apakah ada ENV Host Server?
    - Ada: Pake Mode Server (Production/Docker) üöÄ
    - Ga ada: Pake Mode File (Local Laptop) üìÇ
    """
    host = os.getenv("CHROMA_HOST")
    port = os.getenv("CHROMA_PORT")

    if host and port:
        # Client-Server Mode
        return chromadb.HttpClient(host=host, port=int(port))
    else:
        # Local Mode (Fallback)
        return chromadb.PersistentClient(path=DB_PATH)

def _generate_embedding_raw(text):
    """Generate Embedding langsung (Tanpa Cache Streamlit)"""
    client = _get_ai_client_raw()
    try:
        response = client.models.embed_content(
            model="models/gemini-embedding-001",
            contents=text,
            config=types.EmbedContentConfig(task_type="RETRIEVAL_DOCUMENT")
        )
        return response.embeddings[0].values
    except Exception as e:
        print(f"‚ö†Ô∏è Error Embedding AI: {e}")
        return []

# --- 5. STREAMLIT CACHED FUNCTIONS (UNTUK WEB APP) ---
# Fungsi ini khusus untuk Web App agar performa cepat (pake cache).

@st.cache_resource(show_spinner=False)
def get_db_client():
    return _get_db_client_raw()

@st.cache_resource(show_spinner=False)
def get_ai_client():
    return _get_ai_client_raw()

def get_collection():
    client = get_db_client()
    return client.get_or_create_collection(name=COLLECTION_NAME)

@st.cache_data(show_spinner=False)
def generate_embedding_cached(text):
    # Wrapper agar embedding di-cache oleh Streamlit
    return _generate_embedding_raw(text)

# --- 6. INTERNAL HELPER (ID GENERATOR) ---
def _get_next_id_internal(collection):
    data = collection.get(include=[])
    existing_ids = data['ids']
    
    if not existing_ids: return "1"
    
    numeric_ids = []
    for x in existing_ids:
        if x.isdigit(): 
            numeric_ids.append(int(x))
    
    if not numeric_ids: return "1"
    return str(max(numeric_ids) + 1)

# --- 7. CORE LOGIC (READ - USER WEB APP) ---
@retry_on_lock()
def search_faq(query_text, filter_tag=None, n_results=50):
    """
    Digunakan oleh app.py (Web). Menggunakan Embedding Ter-Cache.
    """
    col = get_collection()
    vec = generate_embedding_cached(query_text) # Pake Cache
    
    if not vec: 
        return {"ids": [[]], "metadatas": [[]], "distances": [[]]}

    # Pre-Filtering logic
    where_clause = {"tag": filter_tag} if (filter_tag and filter_tag != "Semua Modul") else None
    
    return col.query(
        query_embeddings=[vec],
        n_results=n_results,
        where=where_clause
    )

@retry_on_lock()
def get_all_faqs_sorted():
    col = get_collection()
    data = col.get(include=['metadatas'])
    
    results = []
    if data['ids']:
        for i, doc_id in enumerate(data['ids']):
            meta = data['metadatas'][i]
            try: id_num = int(doc_id)
            except: id_num = 0
            
            meta['id'] = doc_id
            meta['id_num'] = id_num
            results.append(meta)
            
    results.sort(key=lambda x: x.get('id_num', 0), reverse=True)
    return results

def get_unique_tags_from_db():
    col = get_collection()
    data = col.get(include=['metadatas'])
    unique_tags = set()
    if data['metadatas']:
        for meta in data['metadatas']:
            if meta and meta.get('tag'):
                unique_tags.add(meta['tag'])
    return sorted(list(unique_tags))

# --- 8. CORE LOGIC (WRITE - ADMIN) ---
# Admin selalu diakses via Streamlit, jadi aman pakai retry dan logic biasa.

@st.cache_data(show_spinner=False)
def get_all_data_as_df():
    col = get_collection()
    data = col.get(include=['metadatas', 'documents'])
    
    if not data['ids']: return pd.DataFrame()
    
    rows = []
    for i, doc_id in enumerate(data['ids']):
        meta = data['metadatas'][i]
        rows.append({
            "ID": doc_id,
            "Tag": meta.get('tag'),
            "Judul": meta.get('judul'),
            "Jawaban": meta.get('jawaban_tampil'),
            "Keyword": meta.get('keywords_raw'),
            "Gambar": meta.get('path_gambar'),
            "Source": meta.get('sumber_url'),
            "AI Context": data['documents'][i] if data['documents'] else ""
        })
    
    df = pd.DataFrame(rows)
    df['ID_Num'] = pd.to_numeric(df['ID'], errors='coerce').fillna(0)
    return df.sort_values('ID_Num', ascending=False).drop(columns=['ID_Num'])

@retry_on_lock()
def upsert_faq(doc_id, tag, judul, jawaban, keyword, img_paths, src_url):
    col = get_collection()
    
    final_id = str(doc_id)
    if doc_id == "auto" or doc_id is None:
        final_id = _get_next_id_internal(col)
    
    clean_jawaban = clean_text_for_embedding(jawaban)
    
    try:
        tags_config = load_tags_config()
        tag_desc = tags_config.get(tag, {}).get("desc", "")
    except:
        tag_desc = ""
    
    domain_str = f"{tag} ({tag_desc})" if tag_desc else tag

    # Format Embedding HyDE
    text_embed = f"""DOMAIN: {domain_str}
DOKUMEN: {judul}
VARIASI PERTANYAAN USER: {keyword}
ISI KONTEN: {clean_jawaban}"""
    
    # Gunakan cached embedding agar konsisten, toh ini proses lambat (write)
    vector = generate_embedding_cached(text_embed)
    
    col.upsert(
        ids=[final_id],
        embeddings=[vector],
        documents=[text_embed],
        metadatas=[{
            "tag": tag, 
            "judul": judul, 
            "jawaban_tampil": jawaban, 
            "keywords_raw": keyword,
            "path_gambar": img_paths,
            "sumber_url": src_url
        }]
    )
    return final_id

@retry_on_lock()
def delete_faq(doc_id):
    col = get_collection()
    try:
        data = col.get(ids=[str(doc_id)], include=['metadatas'])
        if data['metadatas'] and len(data['metadatas']) > 0:
            meta = data['metadatas'][0]
            img_str = meta.get('path_gambar', 'none')
            if img_str and img_str.lower() != 'none':
                paths = img_str.split(';')
                for p in paths:
                    clean_path = p.replace("\\", "/")
                    if os.path.exists(clean_path):
                        try:
                            os.remove(clean_path)
                            print(f"üóëÔ∏è Zombie File Deleted: {clean_path}")
                        except Exception as e:
                            print(f"‚ö†Ô∏è Gagal hapus file {clean_path}: {e}")
    except Exception as e:
        print(f"‚ö†Ô∏è Error cleaning images: {e}")

    col.delete(ids=[str(doc_id)])

# --- 9. SPECIAL FUNCTION FOR BOT WA (NO STREAMLIT DEPENDENCY) ---
@retry_on_lock()
def search_faq_for_bot(query_text, filter_tag="Semua Modul"):
    """
    Fungsi khusus untuk Bot WA / API External.
    MANDIRI: Membuka koneksi sendiri, Embedding sendiri tanpa Cache Streamlit.
    """
    # 1. Buka Koneksi Raw (Tanpa st.cache_resource)
    client = _get_db_client_raw()
    col = client.get_or_create_collection(name=COLLECTION_NAME)
    
    # 2. Embedding Raw (Tanpa st.cache_data)
    vec = _generate_embedding_raw(query_text)
    
    if not vec: 
        return None # Return None jika gagal embedding

    # 3. Filtering Logic
    where_clause = {"tag": filter_tag} if (filter_tag and filter_tag != "Semua Modul") else None
    
    # 4. Query
    results = col.query(
        query_embeddings=[vec],
        n_results=5, # Ambil Top 5 aja buat Bot
        where=where_clause
    )
    
    return results

======== FILE: .\src\utils.py ========
import os
import json
import re
import random
import string
import time
import csv
from datetime import datetime
from .config import TAGS_FILE, IMAGES_DIR, BASE_DIR 

# --- DAFTAR WARNA RESMI STREAMLIT (Restricted Palette) ---
# Admin hanya boleh memilih warna ini agar badge di UI User valid
COLOR_PALETTE = {
    "Merah":            {"hex": "#FF4B4B", "name": "red"},
    "Hijau":            {"hex": "#2ECC71", "name": "green"},
    "Biru":             {"hex": "#3498DB", "name": "blue"},
    "Orange":           {"hex": "#FFA500", "name": "orange"},
    "Ungu":             {"hex": "#9B59B6", "name": "violet"},
    "Abu-abu":          {"hex": "#808080", "name": "gray"},
    "Pelangi (Special)":{"hex": "#333333", "name": "rainbow"}
}

# --- 1. JSON TAG CONFIG ---
def load_tags_config():
    if not os.path.exists(TAGS_FILE):
        # Default struktur (Nested Dict)
        default_tags = {
            "ED": {"color": "#FF4B4B", "desc": "IGD, Emergency, Triage, Ambulans"},
            "OPD": {"color": "#2ECC71", "desc": "Rawat Jalan, Poli, Dokter Spesialis"},
            "IPD": {"color": "#3498DB", "desc": "Rawat Inap, Bangsal, Bed, Visite"},
            "Umum": {"color": "#808080", "desc": "General Info, IT Support"}
        }
        save_tags_config(default_tags)
        return default_tags
    with open(TAGS_FILE, "r") as f:
        return json.load(f)

def save_tags_config(tags_dict):
    with open(TAGS_FILE, "w") as f:
        json.dump(tags_dict, f, indent=4)

# --- 2. SAFE ID GENERATOR ---
def get_next_id_safe(collection):
    try:
        data = collection.get(include=[])
        existing_ids = data['ids']
        if not existing_ids: return "1"
        
        # Filter hanya ID angka agar sorting benar
        numeric_ids = []
        for x in existing_ids:
            if x.isdigit():
                numeric_ids.append(int(x))
        
        if not numeric_ids: return "1"
        return str(max(numeric_ids) + 1)
    except Exception:
        return str(int(time.time()))

# --- 3. IMAGE HANDLING ---
def sanitize_filename(text):
    # Membersihkan nama file dari karakter aneh
    return re.sub(r'[^\w\-_]', '', text.replace(" ", "_"))[:30]

def save_uploaded_images(uploaded_files, judul, tag):
    if not uploaded_files: return "none"
    
    saved_paths = []
    clean_judul = sanitize_filename(judul)
    target_dir = os.path.join(IMAGES_DIR, tag)
    os.makedirs(target_dir, exist_ok=True)
    
    for i, file in enumerate(uploaded_files):
        ext = file.name.split('.')[-1]
        # Tambah random suffix biar gak bentrok
        suffix = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
        
        filename = f"{clean_judul}_{tag}_{i+1}_{suffix}.{ext}"
        full_path = os.path.join(target_dir, filename)
        
        with open(full_path, "wb") as f:
            f.write(file.getbuffer())
            
        # Simpan relative path agar portable (Docker/Local)
        rel_path = f"./images/{tag}/{filename}"
        saved_paths.append(rel_path)
        
    return ";".join(saved_paths)

def fix_image_path_for_ui(db_path):
    clean = str(db_path).strip('"').strip("'")
    if clean.lower() == "none": return None
    clean = clean.replace("\\", "/")
    if clean.startswith("./"):
        return clean 
    return clean

# --- 4. TEXT CLEANING FOR AI ---
def clean_text_for_embedding(text):
    """
    Menghapus tag [GAMBAR X] agar tidak menjadi noise bagi AI.
    Tapi MEMPERTAHANKAN markdown seperti **bold** atau list.
    Contoh: "Klik [GAMBAR 1] tombol save" -> "Klik tombol save"
    """
    if not text: return ""
    # Hapus pattern [GAMBAR angka] case insensitive
    clean = re.sub(r'\[GAMBAR\s*\d+\]', '', text, flags=re.IGNORECASE)
    # Hapus whitespace berlebih akibat penghapusan tadi
    return " ".join(clean.split())

def log_failed_search(query):
    """Mencatat pencarian yang hasilnya 0 ke file CSV"""
    filename = os.path.join(BASE_DIR, "data", "failed_searches.csv")
    
    # Cek header kalau file baru
    file_exists = os.path.exists(filename)
    
    try:
        with open(filename, mode='a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            if not file_exists:
                writer.writerow(["Timestamp", "Query User"]) # Header
            
            writer.writerow([datetime.now().strftime("%Y-%m-%d %H:%M:%S"), query])
    except Exception as e:
        print(f"Gagal mencatat log: {e}")

======== FILE: .\src\__init__.py ========


======== FILE: .\web_v2\main.py ========
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse
from fastapi.templating import Jinja2Templates
from fastapi.staticfiles import StaticFiles
import uvicorn
import os
import sys
import markdown
import re
import math # Penting untuk hitung halaman

# Setup path agar bisa import dari folder src
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from src import database, utils

app = FastAPI()

# --- SETUP STATIC FILES ---
current_dir = os.path.dirname(os.path.abspath(__file__))
static_dir = os.path.join(current_dir, "static")
os.makedirs(static_dir, exist_ok=True)

app.mount("/static", StaticFiles(directory=static_dir), name="static")
app.mount("/images", StaticFiles(directory=os.path.join(os.path.dirname(current_dir), "images")), name="images")

templates = Jinja2Templates(directory=os.path.join(current_dir, "templates"))
TAGS_MAP = utils.load_tags_config()

# --- HELPER: TEXT PROCESSOR ---
def fix_markdown_format(text):
    """
    Memperbaiki teks agar List dan Baris Baru terbaca oleh Markdown standar.
    """
    if not text: return ""

    # 1. Paksa List Angka (1. dst) punya enter ganda sebelumnya
    # Pola: (Huruf/Titik) -> Enter -> (Angka)(Titik)(Spasi)
    # Diubah jadi: (Huruf/Titik) -> Enter -> Enter -> (Angka)...
    text = re.sub(r'([^\n])\n(\d+\.\s)', r'\1\n\n\2', text)
    
    # 2. Paksa List Bullet (- dst) punya enter ganda sebelumnya
    text = re.sub(r'([^\n])\n(-\s)', r'\1\n\n\2', text)

    return text

def process_content_to_html(text_markdown, img_path_str):
    if not text_markdown: return ""
    
    # LANGKAH 1: Perbaiki format teks mentah dulu (Regex)
    text_markdown = fix_markdown_format(text_markdown)
    
    # LANGKAH 2: Convert Markdown -> HTML
    # 'nl2br': Mengubah newlines (\n) menjadi <br> (agar enter terbaca)
    # 'extra': Support fitur markdown tambahan (tabel, dll)
    # 'sane_lists': Agar list angka/bullet tidak tercampur aduk
    try:
        html_content = markdown.markdown(
            text_markdown, 
            extensions=['nl2br', 'extra', 'sane_lists']
        )
    except Exception as e:
        # Fallback jika extension error, pakai basic saja
        print(f"Markdown Error: {e}")
        html_content = markdown.markdown(text_markdown)

    # LANGKAH 3: Parse Image Paths (Logic Gambar SAMA SEPERTI SEBELUMNYA)
    img_list = []
    if img_path_str and str(img_path_str).lower() != 'none':
        raw_paths = img_path_str.split(';')
        for p in raw_paths:
            clean = p.replace("\\", "/").strip()
            if clean.startswith("./images"):
                clean = clean[1:] 
            img_list.append(clean)

    # LANGKAH 4: Replace [GAMBAR X] dengan HTML <img>
    pattern = re.compile(r'\[GAMBAR\s*(\d+)\]', re.IGNORECASE)
    
    def replace_match(match):
        try:
            idx = int(match.group(1)) - 1
            if 0 <= idx < len(img_list):
                return f'''
                <div class="img-container">
                    <img src="{img_list[idx]}" alt="Gambar {idx+1}" loading="lazy" onclick="window.open(this.src, '_blank');">
                    <span class="img-caption">Gambar {idx+1} (Klik untuk perbesar)</span>
                </div>
                '''
            return ""
        except: return ""

    html_content = pattern.sub(replace_match, html_content)

    # Fallback Gallery
    if "[GAMBAR" not in text_markdown.upper() and img_list:
        html_content += "<hr class='img-divider'><div class='gallery-grid'>"
        for img in img_list:
             html_content += f'<div class="img-card"><img src="{img}" onclick="window.open(this.src, \'_blank\');"></div>'
        html_content += "</div>"

    return html_content

# --- MAIN ENDPOINT ---
@app.get("/", response_class=HTMLResponse)
async def read_root(request: Request, q: str = "", tag: str = "Semua Modul", page: int = 0):
    
    ITEMS_PER_PAGE = 10
    results = []
    total_pages = 1
    is_search_mode = False

    # Ambil list tag untuk dropdown
    try: db_tags = database.get_unique_tags_from_db()
    except: db_tags = []
    all_tags = ["Semua Modul"] + (db_tags if db_tags else [])

    # === SKENARIO 1: SEARCH MODE (Top 3) ===
    if q.strip():
        is_search_mode = True
        raw = database.search_faq(q, filter_tag=tag, n_results=20)
        
        if raw and raw['ids'][0]:
            temp_results = []
            for i in range(len(raw['ids'][0])):
                meta = raw['metadatas'][0][i]
                dist = raw['distances'][0][i]
                score = max(0, (1 - dist) * 100)
                
                # Syarat Relevansi > 32%
                if score > 32:
                    meta['score'] = int(score)
                    if score > 80: meta['score_class'] = "score-high"
                    elif score > 50: meta['score_class'] = "score-med"
                    else: meta['score_class'] = "score-low"
                    
                    # Tambahkan warna badge
                    tag_info = TAGS_MAP.get(meta['tag'], {})
                    meta['badge_color'] = tag_info.get('color', '#808080')
                    
                    temp_results.append(meta)
            
            # Sortir Score Tertinggi -> Ambil Top 3 Saja (Request User)
            temp_results.sort(key=lambda x: x['score'], reverse=True)
            results = temp_results[:3]

    # === SKENARIO 2: BROWSE MODE (Terbaru + Paginasi) ===
    else:
        # Ambil semua data terurut ID Descending (Terbaru)
        raw_all = database.get_all_faqs_sorted()
        
        # Filter Tag Manual (karena Chroma get() tidak support where complex di versi lama)
        if tag != "Semua Modul":
            filtered_data = [x for x in raw_all if x.get('tag') == tag]
        else:
            filtered_data = raw_all
            
        # Hitung Paginasi
        total_docs = len(filtered_data)
        total_pages = math.ceil(total_docs / ITEMS_PER_PAGE)
        
        # Guard: jangan sampai page melebihi total
        if page >= total_pages: page = 0
        if page < 0: page = 0
        
        start = page * ITEMS_PER_PAGE
        end = start + ITEMS_PER_PAGE
        
        # Slice data untuk halaman ini
        sliced_data = filtered_data[start:end]
        
        for meta in sliced_data:
            # Setup metadata default untuk tampilan
            meta['score'] = None # Tidak ada score relevansi kalau mode browse
            tag_info = TAGS_MAP.get(meta['tag'], {})
            meta['badge_color'] = tag_info.get('color', '#808080')
            results.append(meta)

    # === PROCESS CONTENT UNTUK SEMUA HASIL ===
    for item in results:
        item['html_content'] = process_content_to_html(
            item.get('jawaban_tampil', ''), 
            item.get('path_gambar', '')
        )

    return templates.TemplateResponse("index.html", {
        "request": request, 
        "results": results, 
        "query": q, 
        "current_tag": tag,
        "all_tags": all_tags,
        
        # Data Paginasi
        "page": page,
        "total_pages": total_pages,
        "is_search_mode": is_search_mode,
        "total_items": len(results)
    })

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8080, reload=True)

======== FILE: .\web_v2\__init__.py ========


